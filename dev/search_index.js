var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LibAwsIO","category":"page"},{"location":"#LibAwsIO","page":"Home","title":"LibAwsIO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LibAwsIO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LibAwsIO]","category":"page"},{"location":"#LibAwsIO.AWS_C_IO_PACKAGE_ID","page":"Home","title":"LibAwsIO.AWS_C_IO_PACKAGE_ID","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsIO.AWS_TLS_NEGOTIATED_PROTOCOL_MESSAGE","page":"Home","title":"LibAwsIO.AWS_TLS_NEGOTIATED_PROTOCOL_MESSAGE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsIO.__JL_Ctag_705","page":"Home","title":"LibAwsIO.__JL_Ctag_705","text":"__JL_Ctag_705\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.__JL_Ctag_709","page":"Home","title":"LibAwsIO.__JL_Ctag_709","text":"__JL_Ctag_709\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.__JL_Ctag_712","page":"Home","title":"LibAwsIO.__JL_Ctag_712","text":"__JL_Ctag_712\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.__JL_Ctag_721","page":"Home","title":"LibAwsIO.__JL_Ctag_721","text":"__JL_Ctag_721\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_address_record_type","page":"Home","title":"LibAwsIO.aws_address_record_type","text":"aws_address_record_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_async_input_stream","page":"Home","title":"LibAwsIO.aws_async_input_stream","text":"aws_async_input_stream\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_async_input_stream_tester","page":"Home","title":"LibAwsIO.aws_async_input_stream_tester","text":"aws_async_input_stream_tester\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_async_input_stream_tester_options","page":"Home","title":"LibAwsIO.aws_async_input_stream_tester_options","text":"aws_async_input_stream_tester_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_async_input_stream_vtable","page":"Home","title":"LibAwsIO.aws_async_input_stream_vtable","text":"aws_async_input_stream_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_async_read_completion_strategy","page":"Home","title":"LibAwsIO.aws_async_read_completion_strategy","text":"aws_async_read_completion_strategy\n\nUse aws_async_input_stream_tester to test edge cases in systems that take async streams. You can customize its behavior (e.g. fail on 3rd read, always complete async, always complete synchronously, etc)\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_autogen_style","page":"Home","title":"LibAwsIO.aws_autogen_style","text":"aws_autogen_style\n\nUse aws_input_stream tester to test edge cases in systems that take input streams. You can make it behave in specific weird ways (e.g. fail on 3rd read).\n\nThere are a few ways to set what gets streamed. - source_bytes: if set, stream these bytes. - source_stream: if set, wrap this stream (but insert weird behavior like failing on 3rd read). - autogen_length: autogen streaming content N bytes in length.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel","page":"Home","title":"LibAwsIO.aws_channel","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_direction","page":"Home","title":"LibAwsIO.aws_channel_direction","text":"aws_channel_direction\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_handler","page":"Home","title":"LibAwsIO.aws_channel_handler","text":"aws_channel_handler\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_handler_vtable","page":"Home","title":"LibAwsIO.aws_channel_handler_vtable","text":"aws_channel_handler_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_on_message_write_completed_fn","page":"Home","title":"LibAwsIO.aws_channel_on_message_write_completed_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_on_protocol_negotiated_fn","page":"Home","title":"LibAwsIO.aws_channel_on_protocol_negotiated_fn","text":"If ALPN is being used this function will be invoked by the channel once an ALPN message is received. The returned channel_handler will be added to, and managed by, the channel.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_on_setup_completed_fn","page":"Home","title":"LibAwsIO.aws_channel_on_setup_completed_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_on_shutdown_completed_fn","page":"Home","title":"LibAwsIO.aws_channel_on_shutdown_completed_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_options","page":"Home","title":"LibAwsIO.aws_channel_options","text":"aws_channel_options\n\nArgs for creating a new channel. event_loop to use for IO and tasks. on_setup_completed will be invoked when the setup process is finished It will be executed in the event loop's thread. on_shutdown_completed will be executed upon channel shutdown.\n\nenable_read_back_pressure toggles whether or not back pressure will be applied in the channel. Leave this option off unless you're using something like reactive-streams, since it is a slight throughput penalty.\n\nUnless otherwise specified all functions for channels and channel slots must be executed within that channel's event-loop's thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_slot","page":"Home","title":"LibAwsIO.aws_channel_slot","text":"aws_channel_slot\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_task","page":"Home","title":"LibAwsIO.aws_channel_task","text":"aws_channel_task\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_channel_task_fn","page":"Home","title":"LibAwsIO.aws_channel_task_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_client_bootstrap","page":"Home","title":"LibAwsIO.aws_client_bootstrap","text":"aws_client_bootstrap\n\naws_client_bootstrap handles creation and setup of channels that communicate via socket with a specific endpoint.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_client_bootstrap_on_channel_event_fn","page":"Home","title":"LibAwsIO.aws_client_bootstrap_on_channel_event_fn","text":"Generic event function for channel lifecycle events.\n\nCallbacks are provided for: (1) Channel creation (2) Channel setup - If TLS is being used, this function is called once the socket has connected, the channel has been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If TLS negotiation fails, this function will be called with the corresponding error code. If TLS is not being used, this function is called once the socket has connected and the channel has been initialized. (3) Channel shutdown\n\nThese callbacks are always invoked within the thread of the event-loop that the channel is assigned to.\n\nThis function does NOT always imply \"success\" â€“ if error_code is AWS_OP_SUCCESS then everything was successful, otherwise an error condition occurred.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_client_bootstrap_options","page":"Home","title":"LibAwsIO.aws_client_bootstrap_options","text":"aws_client_bootstrap_options\n\naws_client_bootstrap creation options.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_client_bootstrap_shutdown_complete_fn","page":"Home","title":"LibAwsIO.aws_client_bootstrap_shutdown_complete_fn","text":"Called after client bootstrap has been completely cleaned up, after its last refcount is released.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_crt_io_statistics_category","page":"Home","title":"LibAwsIO.aws_crt_io_statistics_category","text":"aws_crt_io_statistics_category\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_crt_statistics_socket","page":"Home","title":"LibAwsIO.aws_crt_statistics_socket","text":"aws_crt_statistics_socket\n\nSocket channel handler statistics record\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_crt_statistics_tls","page":"Home","title":"LibAwsIO.aws_crt_statistics_tls","text":"aws_crt_statistics_tls\n\nTls channel handler statistics record\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_custom_key_op_handler","page":"Home","title":"LibAwsIO.aws_custom_key_op_handler","text":"aws_custom_key_op_handler\n\nThe custom key operation that is used when performing a mutual TLS handshake. This can be extended to provide custom private key operations, like PKCS11 or similar.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_custom_key_op_handler_vtable","page":"Home","title":"LibAwsIO.aws_custom_key_op_handler_vtable","text":"aws_custom_key_op_handler_vtable\n\nvtable for aws_custom_key_op_handler.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_event_loop","page":"Home","title":"LibAwsIO.aws_event_loop","text":"aws_event_loop\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_event_loop_group","page":"Home","title":"LibAwsIO.aws_event_loop_group","text":"aws_event_loop_group\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_event_loop_local_object","page":"Home","title":"LibAwsIO.aws_event_loop_local_object","text":"aws_event_loop_local_object\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_event_loop_on_event_fn","page":"Home","title":"LibAwsIO.aws_event_loop_on_event_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_event_loop_on_local_object_removed_fn","page":"Home","title":"LibAwsIO.aws_event_loop_on_local_object_removed_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_event_loop_options","page":"Home","title":"LibAwsIO.aws_event_loop_options","text":"aws_event_loop_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_event_loop_vtable","page":"Home","title":"LibAwsIO.aws_event_loop_vtable","text":"aws_event_loop_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_exponential_backoff_jitter_mode","page":"Home","title":"LibAwsIO.aws_exponential_backoff_jitter_mode","text":"aws_exponential_backoff_jitter_mode\n\nJitter mode for exponential backoff.\n\nFor a great writeup on these options see: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_exponential_backoff_retry_options","page":"Home","title":"LibAwsIO.aws_exponential_backoff_retry_options","text":"aws_exponential_backoff_retry_options\n\nOptions for exponential backoff retry strategy. el_group must be set, any other option, if set to 0 will signify \"use defaults\"\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_bool","page":"Home","title":"LibAwsIO.aws_future_bool","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_callback_fn","page":"Home","title":"LibAwsIO.aws_future_callback_fn","text":"Completion callback for aws_future<T>\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_impl","page":"Home","title":"LibAwsIO.aws_future_impl","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_impl_result_clean_up_fn","page":"Home","title":"LibAwsIO.aws_future_impl_result_clean_up_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_impl_result_destroy_fn","page":"Home","title":"LibAwsIO.aws_future_impl_result_destroy_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_impl_result_release_fn","page":"Home","title":"LibAwsIO.aws_future_impl_result_release_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_size","page":"Home","title":"LibAwsIO.aws_future_size","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_future_void","page":"Home","title":"LibAwsIO.aws_future_void","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_generate_random_fn","page":"Home","title":"LibAwsIO.aws_generate_random_fn","text":"Optional function to supply your own generate random implementation\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_generic_function","page":"Home","title":"LibAwsIO.aws_generic_function","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_get_host_address_flags","page":"Home","title":"LibAwsIO.aws_get_host_address_flags","text":"aws_get_host_address_flags\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_address","page":"Home","title":"LibAwsIO.aws_host_address","text":"aws_host_address\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_listener","page":"Home","title":"LibAwsIO.aws_host_listener","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_listener_options","page":"Home","title":"LibAwsIO.aws_host_listener_options","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_resolution_config","page":"Home","title":"LibAwsIO.aws_host_resolution_config","text":"aws_host_resolution_config\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_resolver","page":"Home","title":"LibAwsIO.aws_host_resolver","text":"aws_host_resolver\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_resolver_default_options","page":"Home","title":"LibAwsIO.aws_host_resolver_default_options","text":"aws_host_resolver_default_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_resolver_purge_host_options","page":"Home","title":"LibAwsIO.aws_host_resolver_purge_host_options","text":"aws_host_resolver_purge_host_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_host_resolver_vtable","page":"Home","title":"LibAwsIO.aws_host_resolver_vtable","text":"aws_host_resolver_vtable\n\nshould you absolutely disdain the default implementation, feel free to implement your own.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_input_stream","page":"Home","title":"LibAwsIO.aws_input_stream","text":"aws_input_stream\n\nBase class for input streams. Note: when you implement one input stream, the ref_count needs to be initialized to clean up the resource when reaches to zero.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_input_stream_tester","page":"Home","title":"LibAwsIO.aws_input_stream_tester","text":"aws_input_stream_tester\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_input_stream_tester_options","page":"Home","title":"LibAwsIO.aws_input_stream_tester_options","text":"aws_input_stream_tester_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_input_stream_vtable","page":"Home","title":"LibAwsIO.aws_input_stream_vtable","text":"aws_input_stream_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_io_clock_fn","page":"Home","title":"LibAwsIO.aws_io_clock_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_io_errors","page":"Home","title":"LibAwsIO.aws_io_errors","text":"aws_io_errors\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_io_event_type","page":"Home","title":"LibAwsIO.aws_io_event_type","text":"aws_io_event_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_io_handle","page":"Home","title":"LibAwsIO.aws_io_handle","text":"aws_io_handle\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_io_log_subject","page":"Home","title":"LibAwsIO.aws_io_log_subject","text":"aws_io_log_subject\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_io_message","page":"Home","title":"LibAwsIO.aws_io_message","text":"aws_io_message\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_io_message_type","page":"Home","title":"LibAwsIO.aws_io_message_type","text":"aws_io_message_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_memory_pool","page":"Home","title":"LibAwsIO.aws_memory_pool","text":"aws_memory_pool\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_message_pool","page":"Home","title":"LibAwsIO.aws_message_pool","text":"aws_message_pool\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_message_pool_creation_args","page":"Home","title":"LibAwsIO.aws_message_pool_creation_args","text":"aws_message_pool_creation_args\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_new_event_loop_fn","page":"Home","title":"LibAwsIO.aws_new_event_loop_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_on_host_resolved_result_fn","page":"Home","title":"LibAwsIO.aws_on_host_resolved_result_fn","text":"Invoked once an address has been resolved for host. The type in host_addresses is struct aws_host_address (by-value). The caller does not own this memory and you must copy the host address before returning from this function if you plan to use it later. For convenience, we've provided the aws_host_address_copy() and aws_host_address_clean_up() functions.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pcks11_lib_behavior","page":"Home","title":"LibAwsIO.aws_pcks11_lib_behavior","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pem_object","page":"Home","title":"LibAwsIO.aws_pem_object","text":"aws_pem_object\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pem_object_type","page":"Home","title":"LibAwsIO.aws_pem_object_type","text":"aws_pem_object_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pipe_on_readable_fn","page":"Home","title":"LibAwsIO.aws_pipe_on_readable_fn","text":"Callback for when the pipe is readable (edge-triggered), or an error has occurred. Afer subscribing, the callback is invoked when the pipe has data to read, or the pipe has an error. The readable callback is invoked again any time the user reads all data, and then more data arrives. Note that it will not be invoked again if the pipe still has unread data when more data arrives. error_code of AWS_ERROR_SUCCESS indicates a readable event, and otherwise contains the value of the error. user_data corresponds to the user_data passed into aws_pipe_subscribe_to_read_events(). This callback is always invoked on the read-end's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pipe_on_write_completed_fn","page":"Home","title":"LibAwsIO.aws_pipe_on_write_completed_fn","text":"Callback for when the asynchronous aws_pipe_write() operation has either completed or failed. write_end will be NULL if this callback is invoked after the the write-end has been cleaned up, this does not necessarily mean that the write operation failed. error_code will be AWS_ERROR_SUCCESS if all data was written, or a code corresponding to the error. src_buffer corresponds to the buffer passed into aws_pipe_write() user_data corresponds to the user_data passed into aws_pipe_write(). This callback is always invoked on the write-end's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pipe_read_end","page":"Home","title":"LibAwsIO.aws_pipe_read_end","text":"aws_pipe_read_end\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pipe_write_end","page":"Home","title":"LibAwsIO.aws_pipe_write_end","text":"aws_pipe_write_end\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pkcs11_lib","page":"Home","title":"LibAwsIO.aws_pkcs11_lib","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pkcs11_lib_behavior","page":"Home","title":"LibAwsIO.aws_pkcs11_lib_behavior","text":"aws_pkcs11_lib_behavior\n\nControls how aws_pkcs11_lib calls C_Initialize() and C_Finalize() on the PKCS#11 library.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pkcs11_lib_options","page":"Home","title":"LibAwsIO.aws_pkcs11_lib_options","text":"aws_pkcs11_lib_options\n\nOptions for aws_pkcs11_lib_new()\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_pkcs11_session","page":"Home","title":"LibAwsIO.aws_pkcs11_session","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_resolve_host_implementation_fn","page":"Home","title":"LibAwsIO.aws_resolve_host_implementation_fn","text":"Function signature for configuring your own resolver (the default just uses getaddrinfo()). The type in output_addresses is struct aws_host_address (by-value). We assume this function blocks, hence this absurdly complicated design.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_retry_error_type","page":"Home","title":"LibAwsIO.aws_retry_error_type","text":"aws_retry_error_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_retry_strategy","page":"Home","title":"LibAwsIO.aws_retry_strategy","text":"aws_retry_strategy\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_retry_strategy_on_retry_ready_fn","page":"Home","title":"LibAwsIO.aws_retry_strategy_on_retry_ready_fn","text":"Invoked after a successful call to aws_retry_strategy_schedule_retry(). This function will always be invoked if and only if aws_retry_strategy_schedule_retry() returns AWS_OP_SUCCESS. It will never be invoked synchronously from aws_retry_strategy_schedule_retry(). After attempting the operation, either call aws_retry_strategy_schedule_retry() with an aws_retry_error_type or call aws_retry_token_record_success() and then release the token via. aws_retry_token_release().\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_retry_strategy_on_retry_token_acquired_fn","page":"Home","title":"LibAwsIO.aws_retry_strategy_on_retry_token_acquired_fn","text":"Invoked upon the acquisition, or failure to acquire a retry token. This function will always be invoked if and only if aws_retry_strategy_acquire_retry_token() returns AWS_OP_SUCCESS. It will never be invoked synchronously from aws_retry_strategy_acquire_retry_token(). Token will always be NULL if error_code is non-zero, and vice-versa. If token is non-null, it will have a reference count of 1, and you must call aws_retry_token_release() on it later. See the comments for aws_retry_strategy_on_retry_ready_fn for more info.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_retry_strategy_vtable","page":"Home","title":"LibAwsIO.aws_retry_strategy_vtable","text":"aws_retry_strategy_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_retry_token","page":"Home","title":"LibAwsIO.aws_retry_token","text":"aws_retry_token\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_server_bootstrap","page":"Home","title":"LibAwsIO.aws_server_bootstrap","text":"aws_server_bootstrap\n\naws_server_bootstrap manages listening sockets, creating and setting up channels to handle each incoming connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_server_bootstrap_on_accept_channel_setup_fn","page":"Home","title":"LibAwsIO.aws_server_bootstrap_on_accept_channel_setup_fn","text":"If TLS is being used, this function is called once the socket has received an incoming connection, the channel has been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If TLS negotiation fails, this function will be called with the corresponding error code.\n\nIf TLS is not being used, this function is called once the socket has received an incoming connection and the channel has been initialized.\n\nThis function is always called within the thread of the event-loop that the new channel is assigned to upon success.\n\nOn failure, the channel might not be assigned to an event loop yet, and will thus be invoked on the listener's event-loop thread.\n\nThis function does NOT mean \"success\", if error_code is AWS_OP_SUCCESS then everything was successful, otherwise an error condition occurred.\n\nIf an error occurred, you do not need to shutdown the channel. The aws_channel_client_shutdown_callback will be invoked once the channel has finished shutting down.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_server_bootstrap_on_accept_channel_shutdown_fn","page":"Home","title":"LibAwsIO.aws_server_bootstrap_on_accept_channel_shutdown_fn","text":"Once the channel shuts down, this function will be invoked within the thread of the event-loop that the channel is assigned to.\n\nNote: this function is only invoked if the channel was successfully setup, e.g. aws_server_bootstrap_on_accept_channel_setup_fn() was invoked without an error code.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_server_bootstrap_on_server_listener_destroy_fn","page":"Home","title":"LibAwsIO.aws_server_bootstrap_on_server_listener_destroy_fn","text":"Once the server listener socket is finished destroying, and all the existing connections are closed, this fuction will be invoked.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_server_socket_channel_bootstrap_options","page":"Home","title":"LibAwsIO.aws_server_socket_channel_bootstrap_options","text":"aws_server_socket_channel_bootstrap_options\n\nArguments to setup a server socket listener which will also negotiate and configure TLS. This creates a socket listener bound to host and 'port' using socket options options, and TLS options tls_options. incoming_callback will be invoked once an incoming channel is ready for use and TLS is finished negotiating, or if an error is encountered. shutdown_callback will be invoked once the channel has shutdown. destroy_callback will be invoked after the server socket listener is destroyed, and all associated connections and channels have finished shutting down. Immediately after the shutdown_callback returns, the channel is cleaned up automatically. All callbacks are invoked in the thread of the event-loop that listener is assigned to.\n\nUpon shutdown of your application, you'll want to call aws_server_bootstrap_destroy_socket_listener with the return value from this function.\n\nThe socket type in options must be AWS_SOCKET_STREAM if tls_options is set. DTLS is not currently supported for tls.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_shared_library","page":"Home","title":"LibAwsIO.aws_shared_library","text":"aws_shared_library\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket","page":"Home","title":"LibAwsIO.aws_socket","text":"aws_socket\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_channel_bootstrap_options","page":"Home","title":"LibAwsIO.aws_socket_channel_bootstrap_options","text":"aws_socket_channel_bootstrap_options\n\nSocket-based channel creation options.\n\nbootstrap - configs name resolution and which event loop group the connection will be seated into host_name - host to connect to; if a dns address, will be resolved prior to connecting port - port to connect to socket_options - socket properties, including type (tcp vs. udp vs. unix domain) and connect timeout. TLS connections are currently restricted to tcp (AWS_SOCKET_STREAM) only. tls_options - (optional) tls context to apply after connection establishment. If NULL, the connection will not be protected by TLS. creation_callback - (optional) callback invoked when the channel is first created. This is always right after the connection was successfully established. Does NOT get called if the initial connect failed. setup_callback - callback invoked once the channel is ready for use and TLS has been negotiated or if an error is encountered shutdown_callback - callback invoked once the channel has shutdown. enable_read_back_pressure - controls whether or not back pressure will be applied in the channel user_data - arbitrary data to pass back to the various callbacks requested_event_loop - if set, the connection will be placed on the requested event loop rather than one chosen internally from the bootstrap's associated event loop group. It is an error to pass in an event loop that is not associated with the bootstrap's event loop group.\n\nImmediately after the shutdown_callback returns, the channel is cleaned up automatically. All callbacks are invoked in the thread of the event-loop that the new channel is assigned to.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_domain","page":"Home","title":"LibAwsIO.aws_socket_domain","text":"aws_socket_domain\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_endpoint","page":"Home","title":"LibAwsIO.aws_socket_endpoint","text":"aws_socket_endpoint\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_on_accept_result_fn","page":"Home","title":"LibAwsIO.aws_socket_on_accept_result_fn","text":"Called by a listening socket when either an incoming connection has been received or an error occurred.\n\nIn the normal use-case, this function will be called multiple times over the lifetime of a single listening socket. new_socket is already connected and initialized, and is using the same options and allocator as the listening socket. A user may want to call aws_socket_set_options() on the new socket if different options are desired.\n\nnew_socket is not yet assigned to an event-loop. The user should call aws_socket_assign_to_event_loop() before performing IO operations.\n\nWhen error_code is AWS_ERROR_SUCCESS, new_socket is the recently accepted connection. If error_code is non-zero, an error occurred and you should aws_socket_close() the socket.\n\nDo not call aws_socket_clean_up() from this callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_on_connection_result_fn","page":"Home","title":"LibAwsIO.aws_socket_on_connection_result_fn","text":"Called in client mode when an outgoing connection has succeeded or an error has occurred. If the connection was successful error_code will be AWS_ERROR_SUCCESS and the socket has already been assigned to the event loop specified in aws_socket_connect().\n\nIf an error occurred error_code will be non-zero.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_on_readable_fn","page":"Home","title":"LibAwsIO.aws_socket_on_readable_fn","text":"Callback for when socket is either readable (edge-triggered) or when an error has occurred. If the socket is readable, error_code will be AWS_ERROR_SUCCESS.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_on_write_completed_fn","page":"Home","title":"LibAwsIO.aws_socket_on_write_completed_fn","text":"Callback for when the data passed to a call to aws_socket_write() has either completed or failed. On success, error_code will be AWS_ERROR_SUCCESS.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_options","page":"Home","title":"LibAwsIO.aws_socket_options","text":"aws_socket_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_socket_type","page":"Home","title":"LibAwsIO.aws_socket_type","text":"aws_socket_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_standard_retry_options","page":"Home","title":"LibAwsIO.aws_standard_retry_options","text":"aws_standard_retry_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_stream_seek_basis","page":"Home","title":"LibAwsIO.aws_stream_seek_basis","text":"aws_stream_seek_basis\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_stream_status","page":"Home","title":"LibAwsIO.aws_stream_status","text":"aws_stream_status\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_testing_channel_options","page":"Home","title":"LibAwsIO.aws_testing_channel_options","text":"aws_testing_channel_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_cipher_pref","page":"Home","title":"LibAwsIO.aws_tls_cipher_pref","text":"aws_tls_cipher_pref\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_connection_options","page":"Home","title":"LibAwsIO.aws_tls_connection_options","text":"aws_tls_connection_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_ctx","page":"Home","title":"LibAwsIO.aws_tls_ctx","text":"aws_tls_ctx\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_ctx_options","page":"Home","title":"LibAwsIO.aws_tls_ctx_options","text":"aws_tls_ctx_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_ctx_pkcs11_options","page":"Home","title":"LibAwsIO.aws_tls_ctx_pkcs11_options","text":"aws_tls_ctx_pkcs11_options\n\nThis struct exists as a graceful way to pass many arguments when calling init-with-pkcs11 functions on aws_tls_ctx_options (this also makes it easy to introduce optional arguments in the future). Instances of this struct should only exist briefly on the stack.\n\nInstructions for binding this to high-level languages: - Python: The members of this struct should be the keyword args to the init-with-pkcs11 functions. - JavaScript: This should be an options map passed to init-with-pkcs11 functions. - Java: This should be an options class passed to init-with-pkcs11 functions. - C++: Same as Java\n\nNotes on integer types: PKCS#11 uses unsigned long for IDs, handles, etc but we expose them as uint64_t in public APIs. We do this because sizeof(long) is inconsistent across platform/arch/language (ex: always 64bit in Java, always 32bit in C on Windows, matches CPU in C on Linux and Apple). By using uint64_t in our public API, we can keep the careful bounds-checking all in one place, instead of expecting each high-level language binding to get it just right.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_hash_algorithm","page":"Home","title":"LibAwsIO.aws_tls_hash_algorithm","text":"aws_tls_hash_algorithm\n\nThe hash algorithm of a TLS private key operation. Any custom private key operation handlers are expected to perform operations on the input TLS data using the correct hash algorithm or fail the operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_key_operation","page":"Home","title":"LibAwsIO.aws_tls_key_operation","text":"A struct containing all of the data needed for a private key operation when making a mutual TLS connection. This struct contains the data that needs to be operated on, like performing a sign operation or a decrypt operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_key_operation_type","page":"Home","title":"LibAwsIO.aws_tls_key_operation_type","text":"aws_tls_key_operation_type\n\nThe TLS private key operation that needs to be performed by a custom private key operation handler when making a connection using mutual TLS.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_negotiated_protocol_message","page":"Home","title":"LibAwsIO.aws_tls_negotiated_protocol_message","text":"aws_tls_negotiated_protocol_message\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_negotiation_status","page":"Home","title":"LibAwsIO.aws_tls_negotiation_status","text":"aws_tls_negotiation_status\n\nAn enum for the current state of tls negotiation within a tls channel handler\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_on_data_read_fn","page":"Home","title":"LibAwsIO.aws_tls_on_data_read_fn","text":"Only used if the TLS handler is the last handler in the channel. This allows you to read any data that was read and decrypted by the handler. If you have application protocol channel handlers, this function is not necessary and certainly not recommended.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_on_error_fn","page":"Home","title":"LibAwsIO.aws_tls_on_error_fn","text":"Invoked when an error occurs in the TLS state machine AFTER the handshake has completed. This function should only be used in conjunction with the rules of aws_tls_on_data_read_fn.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_on_negotiation_result_fn","page":"Home","title":"LibAwsIO.aws_tls_on_negotiation_result_fn","text":"Invoked upon completion of the TLS handshake. If successful error_code will be AWS_OP_SUCCESS, otherwise the negotiation failed and immediately after this function is invoked, the channel will be shutting down.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_on_protocol_negotiated","page":"Home","title":"LibAwsIO.aws_tls_on_protocol_negotiated","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_signature_algorithm","page":"Home","title":"LibAwsIO.aws_tls_signature_algorithm","text":"aws_tls_signature_algorithm\n\nThe signature of a TLS private key operation. Any custom private key operation handlers are expected to perform operations on the input TLS data using the correct signature algorithm or fail the operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_tls_versions","page":"Home","title":"LibAwsIO.aws_tls_versions","text":"aws_tls_versions\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.testing_channel","page":"Home","title":"LibAwsIO.testing_channel","text":"testing_channel\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.testing_channel_handler","page":"Home","title":"LibAwsIO.testing_channel_handler","text":"testing_channel_handler\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.testing_channel_handler_on_shutdown_fn","page":"Home","title":"LibAwsIO.testing_channel_handler_on_shutdown_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.testing_loop","page":"Home","title":"LibAwsIO.testing_loop","text":"testing_loop\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsIO.aws_async_input_stream_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_async_input_stream_acquire","text":"aws_async_input_stream_acquire(stream)\n\nIncrement reference count. You may pass in NULL (has no effect). Returns whatever pointer was passed in.\n\nPrototype\n\nstruct aws_async_input_stream *aws_async_input_stream_acquire(struct aws_async_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_async_input_stream_init_base-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_async_input_stream_init_base","text":"aws_async_input_stream_init_base(stream, alloc, vtable, impl)\n\nInitialize aws_async_input_stream \"base class\"\n\nPrototype\n\nvoid aws_async_input_stream_init_base( struct aws_async_input_stream *stream, struct aws_allocator *alloc, const struct aws_async_input_stream_vtable *vtable, void *impl);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_async_input_stream_new_tester-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_async_input_stream_new_tester","text":"aws_async_input_stream_new_tester(alloc, options)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline struct aws_async_input_stream *aws_async_input_stream_new_tester( struct aws_allocator *alloc, const struct aws_async_input_stream_tester_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_async_input_stream_read-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_async_input_stream_read","text":"aws_async_input_stream_read(stream, dest)\n\nRead once from the async stream into the buffer. The read completes when at least 1 byte is read, the buffer is full, or EOF is reached. Depending on implementation, the read could complete at any time. It may complete synchronously. It may complete on another thread. Returns a future, which will contain an error code if something went wrong, or a result bool indicating whether EOF has been reached.\n\nWARNING: The buffer must have space available. WARNING: Do not read again until the previous read is complete.\n\nPrototype\n\nstruct aws_future_bool *aws_async_input_stream_read(struct aws_async_input_stream *stream, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_async_input_stream_read_to_fill-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_async_input_stream_read_to_fill","text":"aws_async_input_stream_read_to_fill(stream, dest)\n\nRead repeatedly from the async stream until the buffer is full, or EOF is reached. Depending on implementation, this could complete at any time. It may complete synchronously. It may complete on another thread. Returns a future, which will contain an error code if something went wrong, or a result bool indicating whether EOF has been reached.\n\nWARNING: The buffer must have space available. WARNING: Do not read again until the previous read is complete.\n\nPrototype\n\nstruct aws_future_bool *aws_async_input_stream_read_to_fill( struct aws_async_input_stream *stream, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_async_input_stream_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_async_input_stream_release","text":"aws_async_input_stream_release(stream)\n\nDecrement reference count. You may pass in NULL (has no effect). Always returns NULL.\n\nPrototype\n\nstruct aws_async_input_stream *aws_async_input_stream_release(struct aws_async_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_async_input_stream_tester_total_bytes_read-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_async_input_stream_tester_total_bytes_read","text":"aws_async_input_stream_tester_total_bytes_read(async_stream)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline uint64_t aws_async_input_stream_tester_total_bytes_read( const struct aws_async_input_stream *async_stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_acquire_hold-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_acquire_hold","text":"aws_channel_acquire_hold(channel)\n\nPrevent a channel's memory from being freed. Any number of users may acquire a hold to prevent a channel and its handlers from being unexpectedly freed. Any user which acquires a hold must release it via aws_channel_release_hold(). Memory will be freed once all holds are released and aws_channel_destroy() has been called.\n\nPrototype\n\nvoid aws_channel_acquire_hold(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_acquire_message_from_pool-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_acquire_message_from_pool","text":"aws_channel_acquire_message_from_pool(channel, message_type, size_hint)\n\nAcquires a message from the event loop's message pool. size_hint is merely a hint, it may be smaller than you requested and you are responsible for checking the bounds of it. If the returned message is not large enough, you must send multiple messages.\n\nPrototype\n\nstruct aws_io_message *aws_channel_acquire_message_from_pool( struct aws_channel *channel, enum aws_io_message_type message_type, size_t size_hint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_current_clock_time-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_current_clock_time","text":"aws_channel_current_clock_time(channel, time_nanos)\n\nFetches the current timestamp from the event-loop's clock, in nanoseconds.\n\nPrototype\n\nint aws_channel_current_clock_time(struct aws_channel *channel, uint64_t *time_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_destroy","text":"aws_channel_destroy(channel)\n\nMark the channel, along with all slots and handlers, for destruction. Must be called after shutdown has completed. Can be called from any thread assuming 'aws_channel_shutdown()' has completed. Note that memory will not be freed until all users which acquired holds on the channel via aws_channel_acquire_hold(), release them via aws_channel_release_hold().\n\nPrototype\n\nvoid aws_channel_destroy(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_fetch_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_fetch_local_object","text":"aws_channel_fetch_local_object(channel, key, obj)\n\nRetrieves an object by key from the event loop's local storage.\n\nPrototype\n\nint aws_channel_fetch_local_object( struct aws_channel *channel, const void *key, struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_get_event_loop-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_get_event_loop","text":"aws_channel_get_event_loop(channel)\n\nFetches the event loop the channel is a part of.\n\nPrototype\n\nstruct aws_event_loop *aws_channel_get_event_loop(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_get_first_slot-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_get_first_slot","text":"aws_channel_get_first_slot(channel)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_channel_slot *aws_channel_get_first_slot(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_handler_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_handler_destroy","text":"aws_channel_handler_destroy(handler)\n\nCalls destroy on handler's vtable\n\nPrototype\n\nvoid aws_channel_handler_destroy(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_handler_increment_read_window-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_handler_increment_read_window","text":"aws_channel_handler_increment_read_window(handler, slot, size)\n\nCalls on_window_update on handler's vtable.\n\nPrototype\n\nint aws_channel_handler_increment_read_window( struct aws_channel_handler *handler, struct aws_channel_slot *slot, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_handler_initial_window_size-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_handler_initial_window_size","text":"aws_channel_handler_initial_window_size(handler)\n\nCalls initial_window_size on handler's vtable.\n\nPrototype\n\nsize_t aws_channel_handler_initial_window_size(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_handler_process_read_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_handler_process_read_message","text":"aws_channel_handler_process_read_message(handler, slot, message)\n\nCalls process_read_message on handler's vtable\n\nPrototype\n\nint aws_channel_handler_process_read_message( struct aws_channel_handler *handler, struct aws_channel_slot *slot, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_handler_process_write_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_handler_process_write_message","text":"aws_channel_handler_process_write_message(handler, slot, message)\n\nCalls process_write_message on handler's vtable.\n\nPrototype\n\nint aws_channel_handler_process_write_message( struct aws_channel_handler *handler, struct aws_channel_slot *slot, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_handler_shutdown-NTuple{5, Any}","page":"Home","title":"LibAwsIO.aws_channel_handler_shutdown","text":"aws_channel_handler_shutdown(handler, slot, dir, error_code, free_scarce_resources_immediately)\n\ncalls shutdown_direction on handler's vtable.\n\nPrototype\n\nint aws_channel_handler_shutdown( struct aws_channel_handler *handler, struct aws_channel_slot *slot, enum aws_channel_direction dir, int error_code, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_new-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_new","text":"aws_channel_new(allocator, creation_args)\n\nAllocates new channel, Unless otherwise specified all functions for channels and channel slots must be executed within that channel's event-loop's thread. channel_options are copied.\n\nPrototype\n\nstruct aws_channel *aws_channel_new(struct aws_allocator *allocator, const struct aws_channel_options *creation_args);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_put_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_put_local_object","text":"aws_channel_put_local_object(channel, key, obj)\n\nStores an object by key in the event loop's local storage.\n\nPrototype\n\nint aws_channel_put_local_object( struct aws_channel *channel, const void *key, const struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_release_hold-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_release_hold","text":"aws_channel_release_hold(channel)\n\nRelease a hold on the channel's memory, allowing it to be freed. This may be called before or after aws_channel_destroy().\n\nPrototype\n\nvoid aws_channel_release_hold(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_remove_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_remove_local_object","text":"aws_channel_remove_local_object(channel, key, removed_obj)\n\nRemoves an object by key from the event loop's local storage.\n\nPrototype\n\nint aws_channel_remove_local_object( struct aws_channel *channel, const void *key, struct aws_event_loop_local_object *removed_obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_schedule_task_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_schedule_task_future","text":"aws_channel_schedule_task_future(channel, task, run_at_nanos)\n\nSchedules a task to run on the event loop at the specified time. This is the ideal way to move a task into the correct thread. It's also handy for context switches. Use aws_channel_current_clock_time() to get the current time in nanoseconds. This function is safe to call from any thread.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_channel_schedule_task_future( struct aws_channel *channel, struct aws_channel_task *task, uint64_t run_at_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_schedule_task_now-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_schedule_task_now","text":"aws_channel_schedule_task_now(channel, task)\n\nSchedules a task to run on the event loop as soon as possible. This is the ideal way to move a task into the correct thread. It's also handy for context switches. This function is safe to call from any thread.\n\nIf called from the channel's event loop, the task will get directly added to the run-now list. If called from outside the channel's event loop, the task will go into a cross-thread task queue.\n\nIf tasks must be serialized relative to some source synchronization, you may not want to use this API because tasks submitted from the event loop thread can \"jump ahead\" of tasks submitted from external threads due to this optimization. If this is a problem, you can either refactor your submission logic or use the aws_channel_schedule_task_now_serialized variant which does not perform this optimization.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_channel_schedule_task_now(struct aws_channel *channel, struct aws_channel_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_schedule_task_now_serialized-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_schedule_task_now_serialized","text":"aws_channel_schedule_task_now_serialized(channel, task)\n\nSchedules a task to run on the event loop as soon as possible.\n\nThis variant always uses the cross thread queue rather than conditionally skipping it when already in the destination event loop. While not \"optimal\", this allows us to serialize task execution no matter where the task was submitted from: if you are submitting tasks from a critical section, the serialized order that you submit is guaranteed to be the order that they execute on the event loop.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_channel_schedule_task_now_serialized(struct aws_channel *channel, struct aws_channel_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_set_statistics_handler-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_set_statistics_handler","text":"aws_channel_set_statistics_handler(channel, handler)\n\nInstrument a channel with a statistics handler. While instrumented with a statistics handler, the channel will periodically report per-channel-handler-specific statistics about handler performance and state.\n\nAssigning a statistics handler to a channel is a transfer of ownership â€“ the channel will clean up the handler appropriately. Statistics handlers may be changed dynamically (for example, the upgrade from a vanilla http channel to a websocket channel), but this function may only be called from the event loop thread that the channel is a part of.\n\nThe first possible hook to set a statistics handler is the channel's creation callback.\n\nPrototype\n\nint aws_channel_set_statistics_handler(struct aws_channel *channel, struct aws_crt_statistics_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_setup_client_tls-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_setup_client_tls","text":"aws_channel_setup_client_tls(right_of_slot, tls_options)\n\n******************************* Misc TLS related ********************************\n\nPrototype\n\nint aws_channel_setup_client_tls( struct aws_channel_slot *right_of_slot, struct aws_tls_connection_options *tls_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_shutdown-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_shutdown","text":"aws_channel_shutdown(channel, error_code)\n\nInitiates shutdown of the channel. Shutdown will begin with the left-most slot. Each handler will invoke 'aws_channel_slot_on_handler_shutdown_complete' once they've finished their shutdown process for the read direction. Once the right-most slot has shutdown in the read direction, the process will start shutting down starting on the right-most slot. Once the left-most slot has shutdown in the write direction, 'callbacks->shutdown_completed' will be invoked in the event loop's thread.\n\nThis function can be called from any thread.\n\nPrototype\n\nint aws_channel_shutdown(struct aws_channel *channel, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_acquire_max_message_for_write-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_acquire_max_message_for_write","text":"aws_channel_slot_acquire_max_message_for_write(slot)\n\nConvenience function that invokes aws_channel_acquire_message_from_pool(), asking for the largest reasonable DATA message that can be sent in the write direction, with upstream overhead accounted for.\n\nPrototype\n\nstruct aws_io_message *aws_channel_slot_acquire_max_message_for_write(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_downstream_read_window-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_downstream_read_window","text":"aws_channel_slot_downstream_read_window(slot)\n\nFetches the downstream read window. This gives you the information necessary to honor the read window. If you call send_message() and it exceeds this window, the message will be rejected.\n\nPrototype\n\nsize_t aws_channel_slot_downstream_read_window(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_increment_read_window","text":"aws_channel_slot_increment_read_window(slot, window)\n\nIssues a window update notification upstream (to the left.)\n\nPrototype\n\nint aws_channel_slot_increment_read_window(struct aws_channel_slot *slot, size_t window);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_insert_end-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_insert_end","text":"aws_channel_slot_insert_end(channel, to_add)\n\nInserts to 'to_add' the end of the channel. Note that the first call to aws_channel_slot_new() adds it to the channel implicitly.\n\nPrototype\n\nint aws_channel_slot_insert_end(struct aws_channel *channel, struct aws_channel_slot *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_insert_left-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_insert_left","text":"aws_channel_slot_insert_left(slot, to_add)\n\ninserts 'to_add' to the position immediately to the left of slot. Note that the first call to aws_channel_slot_new() adds it to the channel implicitly.\n\nPrototype\n\nint aws_channel_slot_insert_left(struct aws_channel_slot *slot, struct aws_channel_slot *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_insert_right-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_insert_right","text":"aws_channel_slot_insert_right(slot, to_add)\n\ninserts 'to_add' to the position immediately to the right of slot. Note that the first call to aws_channel_slot_new() adds it to the channel implicitly.\n\nPrototype\n\nint aws_channel_slot_insert_right(struct aws_channel_slot *slot, struct aws_channel_slot *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_new-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_new","text":"aws_channel_slot_new(channel)\n\nAllocates and initializes a new slot for use with the channel. If this is the first slot in the channel, it will automatically be added to the channel as the first slot. For all subsequent calls on a given channel, the slot will need to be added to the channel via. the aws_channel_slot_insert_right(), aws_channel_slot_insert_end(), and aws_channel_slot_insert_left() APIs.\n\nPrototype\n\nstruct aws_channel_slot *aws_channel_slot_new(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_on_handler_shutdown_complete-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_on_handler_shutdown_complete","text":"aws_channel_slot_on_handler_shutdown_complete(slot, dir, err_code, free_scarce_resources_immediately)\n\nCalled by handlers once they have finished their shutdown in the 'dir' direction. Propagates the shutdown process to the next handler in the channel.\n\nPrototype\n\nint aws_channel_slot_on_handler_shutdown_complete( struct aws_channel_slot *slot, enum aws_channel_direction dir, int err_code, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_remove-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_remove","text":"aws_channel_slot_remove(slot)\n\nRemoves slot from the channel and deallocates the slot and its handler.\n\nPrototype\n\nint aws_channel_slot_remove(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_replace-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_replace","text":"aws_channel_slot_replace(remove, new_slot)\n\nReplaces remove with new_slot. Deallocates remove and its handler.\n\nPrototype\n\nint aws_channel_slot_replace(struct aws_channel_slot *remove, struct aws_channel_slot *new_slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_send_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_send_message","text":"aws_channel_slot_send_message(slot, message, dir)\n\nSends a message to the adjacent slot in the channel based on dir. Also does window size checking.\n\nNOTE: if this function returns an error code, it is the caller's responsibility to release message back to the pool. If this function returns AWS_OP_SUCCESS, the recipient of the message has taken ownership of the message. So, for example, don't release a message to the pool and then return an error. If you encounter an error condition in this case, shutdown the channel with the appropriate error code.\n\nPrototype\n\nint aws_channel_slot_send_message( struct aws_channel_slot *slot, struct aws_io_message *message, enum aws_channel_direction dir);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_set_handler-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_set_handler","text":"aws_channel_slot_set_handler(slot, handler)\n\nSets the handler for a slot, the slot will also call get_current_window_size() and propagate a window update upstream.\n\nPrototype\n\nint aws_channel_slot_set_handler(struct aws_channel_slot *slot, struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_shutdown-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_shutdown","text":"aws_channel_slot_shutdown(slot, dir, err_code, free_scarce_resources_immediately)\n\nInitiates shutdown on slot. callbacks->on_shutdown_completed will be called once the shutdown process is completed.\n\nPrototype\n\nint aws_channel_slot_shutdown( struct aws_channel_slot *slot, enum aws_channel_direction dir, int err_code, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_slot_upstream_message_overhead-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_slot_upstream_message_overhead","text":"aws_channel_slot_upstream_message_overhead(slot)\n\nFetches the current overhead of upstream handlers. This provides a hint to avoid fragmentation if you care.\n\nPrototype\n\nsize_t aws_channel_slot_upstream_message_overhead(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_task_init-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_channel_task_init","text":"aws_channel_task_init(channel_task, task_fn, arg, type_tag)\n\nInitializes channel_task for use.\n\nPrototype\n\nvoid aws_channel_task_init( struct aws_channel_task *channel_task, aws_channel_task_fn *task_fn, void *arg, const char *type_tag);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_thread_is_callers_thread-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_thread_is_callers_thread","text":"aws_channel_thread_is_callers_thread(channel)\n\nReturns true if the caller is on the event loop's thread. If false, you likely need to use aws_channel_schedule_task(). This function is safe to call from any thread.\n\nPrototype\n\nbool aws_channel_thread_is_callers_thread(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_channel_trigger_read-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_channel_trigger_read","text":"aws_channel_trigger_read(channel)\n\nA way for external processes to force a read by the data-source channel handler. Necessary in certain cases, like when a server channel finishes setting up its initial handlers, a read may have already been triggered on the socket (the client's CLIENT_HELLO tls payload, for example) and absent further data/notifications, this data would never get processed.\n\nPrototype\n\nint aws_channel_trigger_read(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_client_bootstrap_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_client_bootstrap_acquire","text":"aws_client_bootstrap_acquire(bootstrap)\n\nIncrements a client bootstrap's ref count, allowing the caller to take a reference to it.\n\nReturns the same client bootstrap passed in.\n\nPrototype\n\nstruct aws_client_bootstrap *aws_client_bootstrap_acquire(struct aws_client_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_client_bootstrap_new-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_client_bootstrap_new","text":"aws_client_bootstrap_new(allocator, options)\n\nCreate the client bootstrap.\n\nPrototype\n\nstruct aws_client_bootstrap *aws_client_bootstrap_new( struct aws_allocator *allocator, const struct aws_client_bootstrap_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_client_bootstrap_new_socket_channel-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_client_bootstrap_new_socket_channel","text":"aws_client_bootstrap_new_socket_channel(options)\n\nSets up a client socket channel.\n\nPrototype\n\nint aws_client_bootstrap_new_socket_channel(struct aws_socket_channel_bootstrap_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_client_bootstrap_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_client_bootstrap_release","text":"aws_client_bootstrap_release(bootstrap)\n\nDecrements a client bootstrap's ref count. When the ref count drops to zero, the bootstrap will be destroyed.\n\nPrototype\n\nvoid aws_client_bootstrap_release(struct aws_client_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_client_bootstrap_set_alpn_callback-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_client_bootstrap_set_alpn_callback","text":"aws_client_bootstrap_set_alpn_callback(bootstrap, on_protocol_negotiated)\n\nWhen using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added to the channel.\n\nPrototype\n\nint aws_client_bootstrap_set_alpn_callback( struct aws_client_bootstrap *bootstrap, aws_channel_on_protocol_negotiated_fn *on_protocol_negotiated);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_crt_statistics_socket_cleanup-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_crt_statistics_socket_cleanup","text":"aws_crt_statistics_socket_cleanup(stats)\n\nCleans up socket channel handler statistics\n\nPrototype\n\nvoid aws_crt_statistics_socket_cleanup(struct aws_crt_statistics_socket *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_crt_statistics_socket_init-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_crt_statistics_socket_init","text":"aws_crt_statistics_socket_init(stats)\n\nInitializes socket channel handler statistics\n\nPrototype\n\nint aws_crt_statistics_socket_init(struct aws_crt_statistics_socket *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_crt_statistics_socket_reset-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_crt_statistics_socket_reset","text":"aws_crt_statistics_socket_reset(stats)\n\nResets socket channel handler statistics for the next gather interval. Calculate-once results are left alone.\n\nPrototype\n\nvoid aws_crt_statistics_socket_reset(struct aws_crt_statistics_socket *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_crt_statistics_tls_cleanup-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_crt_statistics_tls_cleanup","text":"aws_crt_statistics_tls_cleanup(stats)\n\nCleans up tls channel handler statistics\n\nPrototype\n\nvoid aws_crt_statistics_tls_cleanup(struct aws_crt_statistics_tls *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_crt_statistics_tls_init-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_crt_statistics_tls_init","text":"aws_crt_statistics_tls_init(stats)\n\nInitializes tls channel handler statistics\n\nPrototype\n\nint aws_crt_statistics_tls_init(struct aws_crt_statistics_tls *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_crt_statistics_tls_reset-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_crt_statistics_tls_reset","text":"aws_crt_statistics_tls_reset(stats)\n\nResets tls channel handler statistics for the next gather interval. Calculate-once results are left alone.\n\nPrototype\n\nvoid aws_crt_statistics_tls_reset(struct aws_crt_statistics_tls *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_custom_key_op_handler_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_custom_key_op_handler_acquire","text":"aws_custom_key_op_handler_acquire(key_op_handler)\n\nIncreases the reference count for the passed-in aws_custom_key_op_handler and returns it.\n\nPrototype\n\nstruct aws_custom_key_op_handler *aws_custom_key_op_handler_acquire( struct aws_custom_key_op_handler *key_op_handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_custom_key_op_handler_perform_operation-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_custom_key_op_handler_perform_operation","text":"aws_custom_key_op_handler_perform_operation(key_op_handler, operation)\n\nCalls the on_key_operation vtable function. See aws_custom_key_op_handler_vtable for function details.\n\nPrototype\n\nvoid aws_custom_key_op_handler_perform_operation( struct aws_custom_key_op_handler *key_op_handler, struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_custom_key_op_handler_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_custom_key_op_handler_release","text":"aws_custom_key_op_handler_release(key_op_handler)\n\nDecreases the reference count for the passed-in aws_custom_key_op_handler and returns NULL.\n\nPrototype\n\nstruct aws_custom_key_op_handler *aws_custom_key_op_handler_release( struct aws_custom_key_op_handler *key_op_handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_default_dns_resolve-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_default_dns_resolve","text":"aws_default_dns_resolve(allocator, host_name, output_addresses, user_data)\n\nWARNING! do not call this function directly (getaddrinfo()): it blocks. Provide a pointer to this function for other resolution functions.\n\nPrototype\n\nint aws_default_dns_resolve( struct aws_allocator *allocator, const struct aws_string *host_name, struct aws_array_list *output_addresses, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_cancel_task-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_cancel_task","text":"aws_event_loop_cancel_task(event_loop, task)\n\nCancels task. This function must be called from the event loop's thread, and is only guaranteed to work properly on tasks scheduled from within the event loop's thread. The task will be executed with the AWS_TASK_STATUS_CANCELED status inside this call.\n\nPrototype\n\nvoid aws_event_loop_cancel_task(struct aws_event_loop *event_loop, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_clean_up_base-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_clean_up_base","text":"aws_event_loop_clean_up_base(event_loop)\n\nCommon cleanup code for all implementations. This is only called from the *destroy() function of event loop implementations.\n\nPrototype\n\nvoid aws_event_loop_clean_up_base(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_current_clock_time-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_current_clock_time","text":"aws_event_loop_current_clock_time(event_loop, time_nanos)\n\nGets the current timestamp for the event loop's clock, in nanoseconds. This function is thread-safe.\n\nPrototype\n\nint aws_event_loop_current_clock_time(struct aws_event_loop *event_loop, uint64_t *time_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_destroy","text":"aws_event_loop_destroy(event_loop)\n\nInvokes the destroy() fn for the event loop implementation. If the event loop is still in a running state, this function will block waiting on the event loop to shutdown. If you do not want this function to block, call aws_event_loop_stop() manually first. If the event loop is shared by multiple threads then destroy must be called by exactly one thread. All other threads must ensure their API calls to the event loop happen-before the call to destroy.\n\nPrototype\n\nvoid aws_event_loop_destroy(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_fetch_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_fetch_local_object","text":"aws_event_loop_fetch_local_object(event_loop, key, obj)\n\nFetches an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to by key. This function is not thread safe and should be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_fetch_local_object( struct aws_event_loop *event_loop, void *key, struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_free_io_event_resources-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_free_io_event_resources","text":"aws_event_loop_free_io_event_resources(event_loop, handle)\n\nCleans up resources (user_data) associated with the I/O eventing subsystem for a given handle. This should only ever be necessary in the case where you are cleaning up an event loop during shutdown and its thread has already been joined.\n\nPrototype\n\nvoid aws_event_loop_free_io_event_resources(struct aws_event_loop *event_loop, struct aws_io_handle *handle);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_get_load_factor-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_get_load_factor","text":"aws_event_loop_get_load_factor(event_loop)\n\nReturns the current load factor (however that may be calculated). If the event-loop is not invoking aws_event_loop_register_tick_start() and aws_event_loop_register_tick_end(), this value will always be 0.\n\nPrototype\n\nsize_t aws_event_loop_get_load_factor(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_acquire","text":"aws_event_loop_group_acquire(el_group)\n\nIncrements the reference count on the event loop group, allowing the caller to take a reference to it.\n\nReturns the same event loop group passed in.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_acquire(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_get_loop_at-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_get_loop_at","text":"aws_event_loop_group_get_loop_at(el_group, index)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_group_get_loop_at(struct aws_event_loop_group *el_group, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_get_loop_count-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_get_loop_count","text":"aws_event_loop_group_get_loop_count(el_group)\n\nDocumentation not found.\n\nPrototype\n\nsize_t aws_event_loop_group_get_loop_count(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_get_next_loop-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_get_next_loop","text":"aws_event_loop_group_get_next_loop(el_group)\n\nFetches the next loop for use. The purpose is to enable load balancing across loops. You should not depend on how this load balancing is done as it is subject to change in the future. Currently it uses the \"best-of-two\" algorithm based on the load factor of each loop.\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_group_get_next_loop(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_new-NTuple{6, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_new","text":"aws_event_loop_group_new(alloc, clock, el_count, new_loop_fn, new_loop_user_data, shutdown_options)\n\nCreates an event loop group, with clock, number of loops to manage, and the function to call for creating a new event loop.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new( struct aws_allocator *alloc, aws_io_clock_fn *clock, uint16_t el_count, aws_new_event_loop_fn *new_loop_fn, void *new_loop_user_data, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_new_default-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_new_default","text":"aws_event_loop_group_new_default(alloc, max_threads, shutdown_options)\n\nInitializes an event loop group with platform defaults. If max_threads == 0, then the loop count will be the number of available processors on the machine / 2 (to exclude hyper-threads). Otherwise, max_threads will be the number of event loops in the group.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new_default( struct aws_allocator *alloc, uint16_t max_threads, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_new_default_pinned_to_cpu_group-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_new_default_pinned_to_cpu_group","text":"aws_event_loop_group_new_default_pinned_to_cpu_group(alloc, max_threads, cpu_group, shutdown_options)\n\nCreates an event loop group, with clock, number of loops to manage, the function to call for creating a new event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note: If el_count exceeds the number of hw threads in the cpu_group it will be clamped to the number of hw threads on the assumption that if you care about NUMA, you don't want hyper-threads doing your IO and you especially don't want IO on a different node.\n\nIf max_threads == 0, then the loop count will be the number of available processors in the cpu_group / 2 (to exclude hyper-threads)\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new_default_pinned_to_cpu_group( struct aws_allocator *alloc, uint16_t max_threads, uint16_t cpu_group, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_new_pinned_to_cpu_group-NTuple{7, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_new_pinned_to_cpu_group","text":"aws_event_loop_group_new_pinned_to_cpu_group(alloc, clock, el_count, cpu_group, new_loop_fn, new_loop_user_data, shutdown_options)\n\nCreates an event loop group, with clock, number of loops to manage, the function to call for creating a new event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note: If el_count exceeds the number of hw threads in the cpu_group it will be ignored on the assumption that if you care about NUMA, you don't want hyper-threads doing your IO and you especially don't want IO on a different node.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new_pinned_to_cpu_group( struct aws_allocator *alloc, aws_io_clock_fn *clock, uint16_t el_count, uint16_t cpu_group, aws_new_event_loop_fn *new_loop_fn, void *new_loop_user_data, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_group_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_group_release","text":"aws_event_loop_group_release(el_group)\n\nDecrements an event loop group's ref count. When the ref count drops to zero, the event loop group will be destroyed.\n\nPrototype\n\nvoid aws_event_loop_group_release(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_init_base-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_init_base","text":"aws_event_loop_init_base(event_loop, alloc, clock)\n\nInitializes common event-loop data structures. This is only called from the *new() function of event loop implementations.\n\nPrototype\n\nint aws_event_loop_init_base(struct aws_event_loop *event_loop, struct aws_allocator *alloc, aws_io_clock_fn *clock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_new_default-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_new_default","text":"aws_event_loop_new_default(alloc, clock)\n\nCreates an instance of the default event loop implementation for the current architecture and operating system.\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_new_default(struct aws_allocator *alloc, aws_io_clock_fn *clock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_new_default_with_options-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_new_default_with_options","text":"aws_event_loop_new_default_with_options(alloc, options)\n\nCreates an instance of the default event loop implementation for the current architecture and operating system using extendable options.\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_new_default_with_options( struct aws_allocator *alloc, const struct aws_event_loop_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_put_local_object-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_put_local_object","text":"aws_event_loop_put_local_object(event_loop, obj)\n\nPuts an item object the event-loop's data store. Key will be taken as the memory address of the memory pointed to by key. The lifetime of item must live until remove or a put item overrides it. This function is not thread safe and should be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_put_local_object(struct aws_event_loop *event_loop, struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_register_tick_end-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_register_tick_end","text":"aws_event_loop_register_tick_end(event_loop)\n\nFor event-loop implementations to use for providing metrics info to the base event-loop. This enables the event-loop load balancer to take into account load when vending another event-loop to a caller.\n\nCall this function at the end of your event-loop tick: after processing IO and tasks.\n\nPrototype\n\nvoid aws_event_loop_register_tick_end(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_register_tick_start-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_register_tick_start","text":"aws_event_loop_register_tick_start(event_loop)\n\nFor event-loop implementations to use for providing metrics info to the base event-loop. This enables the event-loop load balancer to take into account load when vending another event-loop to a caller.\n\nCall this function at the beginning of your event-loop tick: after wake-up, but before processing any IO or tasks.\n\nPrototype\n\nvoid aws_event_loop_register_tick_start(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_remove_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_remove_local_object","text":"aws_event_loop_remove_local_object(event_loop, key, removed_obj)\n\nRemoves an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to by key. If removed_item is not null, the removed item will be moved to it if it exists. Otherwise, the default deallocation strategy will be used. This function is not thread safe and should be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_remove_local_object( struct aws_event_loop *event_loop, void *key, struct aws_event_loop_local_object *removed_obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_run-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_run","text":"aws_event_loop_run(event_loop)\n\nTriggers the running of the event loop. This function must not block. The event loop is not active until this function is invoked. This function can be called again on an event loop after calling aws_event_loop_stop() and aws_event_loop_wait_for_stop_completion().\n\nPrototype\n\nint aws_event_loop_run(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_schedule_task_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_schedule_task_future","text":"aws_event_loop_schedule_task_future(event_loop, task, run_at_nanos)\n\nThe event loop will schedule the task and run it at the specified time. Use aws_event_loop_current_clock_time() to query the current time in nanoseconds. Note that cancelled tasks may execute outside the event loop thread. This function may be called from outside or inside the event loop thread.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_event_loop_schedule_task_future( struct aws_event_loop *event_loop, struct aws_task *task, uint64_t run_at_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_schedule_task_now-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_schedule_task_now","text":"aws_event_loop_schedule_task_now(event_loop, task)\n\nThe event loop will schedule the task and run it on the event loop thread as soon as possible. Note that cancelled tasks may execute outside the event loop thread. This function may be called from outside or inside the event loop thread.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_event_loop_schedule_task_now(struct aws_event_loop *event_loop, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_stop-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_stop","text":"aws_event_loop_stop(event_loop)\n\nTriggers the event loop to stop, but does not wait for the loop to stop completely. This function may be called from outside or inside the event loop thread. It is safe to call multiple times. This function is called from destroy().\n\nIf you do not call destroy(), an event loop can be run again by calling stop(), wait_for_stop_completion(), run().\n\nPrototype\n\nint aws_event_loop_stop(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_subscribe_to_io_events-NTuple{5, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_subscribe_to_io_events","text":"aws_event_loop_subscribe_to_io_events(event_loop, handle, events, on_event, user_data)\n\nSubscribes on_event to events on the event-loop for handle. events is a bitwise concatenation of the events that were received. The definition for these values can be found in aws_io_event_type. Currently, only AWS_IO_EVENT_TYPE_READABLE and AWS_IO_EVENT_TYPE_WRITABLE are honored. You always are registered for error conditions and closure. This function may be called from outside or inside the event loop thread. However, the unsubscribe function must be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_subscribe_to_io_events( struct aws_event_loop *event_loop, struct aws_io_handle *handle, int events, aws_event_loop_on_event_fn *on_event, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_thread_is_callers_thread-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_thread_is_callers_thread","text":"aws_event_loop_thread_is_callers_thread(event_loop)\n\nReturns true if the event loop's thread is the same thread that called this function, otherwise false.\n\nPrototype\n\nbool aws_event_loop_thread_is_callers_thread(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_unsubscribe_from_io_events-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_event_loop_unsubscribe_from_io_events","text":"aws_event_loop_unsubscribe_from_io_events(event_loop, handle)\n\nUnsubscribes handle from event-loop notifications. This function is not thread safe and should be called inside the event-loop's thread.\n\nNOTE: if you are using io completion ports, this is a risky call. We use it in places, but only when we're certain there's no pending events. If you want to use it, it's your job to make sure you don't have pending events before calling it.\n\nPrototype\n\nint aws_event_loop_unsubscribe_from_io_events(struct aws_event_loop *event_loop, struct aws_io_handle *handle);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_event_loop_wait_for_stop_completion-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_event_loop_wait_for_stop_completion","text":"aws_event_loop_wait_for_stop_completion(event_loop)\n\nBlocks until the event loop stops completely. If you want to call aws_event_loop_run() again, you must call this after aws_event_loop_stop(). It is not safe to call this function from inside the event loop thread.\n\nPrototype\n\nint aws_event_loop_wait_for_stop_completion(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_bool_acquire","text":"aws_future_bool_acquire(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_get_error-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_bool_get_error","text":"aws_future_bool_get_error(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_get_result-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_bool_get_result","text":"aws_future_bool_get_result(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_is_done-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_bool_is_done","text":"aws_future_bool_is_done(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_new-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_bool_new","text":"aws_future_bool_new(alloc)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_bool_register_callback","text":"aws_future_bool_register_callback(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_bool_register_callback_if_not_done","text":"aws_future_bool_register_callback_if_not_done(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_bool_register_channel_callback","text":"aws_future_bool_register_channel_callback(future, channel, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_bool_register_event_loop_callback","text":"aws_future_bool_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_bool_release","text":"aws_future_bool_release(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_set_error-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_bool_set_error","text":"aws_future_bool_set_error(future, error_code)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_set_result-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_bool_set_result","text":"aws_future_bool_set_result(future, result)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_bool_wait-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_bool_wait","text":"aws_future_bool_wait(future, timeout_ns)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_impl_acquire","text":"aws_future_impl_acquire(promise)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_acquire(struct aws_future_impl *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_get_error-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_impl_get_error","text":"aws_future_impl_get_error(future)\n\nDocumentation not found.\n\nPrototype\n\nint aws_future_impl_get_error(const struct aws_future_impl *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_get_result_address-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_impl_get_result_address","text":"aws_future_impl_get_result_address(future)\n\nDocumentation not found.\n\nPrototype\n\nvoid *aws_future_impl_get_result_address(const struct aws_future_impl *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_get_result_by_move-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_get_result_by_move","text":"aws_future_impl_get_result_by_move(future, dst_address)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_future_impl_get_result_by_move(struct aws_future_impl *future, void *dst_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_is_done-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_impl_is_done","text":"aws_future_impl_is_done(future)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_future_impl_is_done(const struct aws_future_impl *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_new_by_value-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_new_by_value","text":"aws_future_impl_new_by_value(alloc, sizeof_result)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_by_value(struct aws_allocator *alloc, size_t sizeof_result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_new_by_value_with_clean_up-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_new_by_value_with_clean_up","text":"aws_future_impl_new_by_value_with_clean_up(alloc, sizeof_result, result_clean_up)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_by_value_with_clean_up( struct aws_allocator *alloc, size_t sizeof_result, aws_future_impl_result_clean_up_fn *result_clean_up);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_new_pointer-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_impl_new_pointer","text":"aws_future_impl_new_pointer(alloc)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_pointer(struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_new_pointer_with_destroy-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_new_pointer_with_destroy","text":"aws_future_impl_new_pointer_with_destroy(alloc, result_destroy)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_pointer_with_destroy( struct aws_allocator *alloc, aws_future_impl_result_destroy_fn *result_destroy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_new_pointer_with_release-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_new_pointer_with_release","text":"aws_future_impl_new_pointer_with_release(alloc, result_release)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_pointer_with_release( struct aws_allocator *alloc, aws_future_impl_result_release_fn *result_release);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_register_callback","text":"aws_future_impl_register_callback(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_future_impl_register_callback( struct aws_future_impl *future, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_register_callback_if_not_done","text":"aws_future_impl_register_callback_if_not_done(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_future_impl_register_callback_if_not_done( struct aws_future_impl *future, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_register_channel_callback","text":"aws_future_impl_register_channel_callback(future, channel, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_future_impl_register_channel_callback( struct aws_future_impl *future, struct aws_channel *channel, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_register_event_loop_callback","text":"aws_future_impl_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_future_impl_register_event_loop_callback( struct aws_future_impl *future, struct aws_event_loop *event_loop, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_impl_release","text":"aws_future_impl_release(promise)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_release(struct aws_future_impl *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_set_error-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_set_error","text":"aws_future_impl_set_error(promise, error_code)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_future_impl_set_error(struct aws_future_impl *promise, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_set_result_by_move-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_set_result_by_move","text":"aws_future_impl_set_result_by_move(promise, src_address)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_future_impl_set_result_by_move(struct aws_future_impl *promise, void *src_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_impl_wait-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_impl_wait","text":"aws_future_impl_wait(future, timeout_ns)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_future_impl_wait(const struct aws_future_impl *future, uint64_t timeout_ns);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_size_acquire","text":"aws_future_size_acquire(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_get_error-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_size_get_error","text":"aws_future_size_get_error(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_get_result-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_size_get_result","text":"aws_future_size_get_result(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_is_done-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_size_is_done","text":"aws_future_size_is_done(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_new-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_size_new","text":"aws_future_size_new(alloc)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_size_register_callback","text":"aws_future_size_register_callback(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_size_register_callback_if_not_done","text":"aws_future_size_register_callback_if_not_done(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_size_register_channel_callback","text":"aws_future_size_register_channel_callback(future, channel, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_size_register_event_loop_callback","text":"aws_future_size_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_size_release","text":"aws_future_size_release(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_set_error-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_size_set_error","text":"aws_future_size_set_error(future, error_code)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_set_result-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_size_set_result","text":"aws_future_size_set_result(future, result)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_size_wait-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_size_wait","text":"aws_future_size_wait(future, timeout_ns)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_void_acquire","text":"aws_future_void_acquire(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_get_error-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_void_get_error","text":"aws_future_void_get_error(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_is_done-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_void_is_done","text":"aws_future_void_is_done(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_new-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_void_new","text":"aws_future_void_new(alloc)\n\naws_future<void>\n\nPrototype\n\nstruct aws_future_void *aws_future_void_new(struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_void_register_callback","text":"aws_future_void_register_callback(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_future_void_register_callback_if_not_done","text":"aws_future_void_register_callback_if_not_done(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_void_register_channel_callback","text":"aws_future_void_register_channel_callback(future, channel, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_future_void_register_event_loop_callback","text":"aws_future_void_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_void_release","text":"aws_future_void_release(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_set_error-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_void_set_error","text":"aws_future_void_set_error(future, error_code)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_set_result-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_future_void_set_result","text":"aws_future_void_set_result(future)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_future_void_set_result(struct aws_future_void *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_future_void_wait-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_future_void_wait","text":"aws_future_void_wait(future, timeout_ns)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_address_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_host_address_clean_up","text":"aws_host_address_clean_up(address)\n\nCleans up the memory for address\n\nPrototype\n\nvoid aws_host_address_clean_up(struct aws_host_address *address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_address_copy-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_host_address_copy","text":"aws_host_address_copy(from, to)\n\nCopies from to to.\n\nPrototype\n\nint aws_host_address_copy(const struct aws_host_address *from, struct aws_host_address *to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_address_move-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_host_address_move","text":"aws_host_address_move(from, to)\n\nMoves from to to. After this call, from is no longer usable. Though, it could be resused for another move or copy operation.\n\nPrototype\n\nvoid aws_host_address_move(struct aws_host_address *from, struct aws_host_address *to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_acquire","text":"aws_host_resolver_acquire(resolver)\n\nIncrements the reference count on the host resolver, allowing the caller to take a reference to it.\n\nReturns the same host resolver passed in.\n\nPrototype\n\nstruct aws_host_resolver *aws_host_resolver_acquire(struct aws_host_resolver *resolver);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_get_host_address_count-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_get_host_address_count","text":"aws_host_resolver_get_host_address_count(resolver, host_name, flags)\n\nget number of addresses for a given host.\n\nPrototype\n\nsize_t aws_host_resolver_get_host_address_count( struct aws_host_resolver *resolver, const struct aws_string *host_name, uint32_t flags);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_init_default_resolution_config-Tuple{}","page":"Home","title":"LibAwsIO.aws_host_resolver_init_default_resolution_config","text":"aws_host_resolver_init_default_resolution_config()\n\nReturns the default host resolution config used internally if none specified.\n\nReturns\n\ndefault host resolution config\n\nPrototype\n\nstruct aws_host_resolution_config aws_host_resolver_init_default_resolution_config(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_new_default-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_new_default","text":"aws_host_resolver_new_default(allocator, options)\n\nCreates a host resolver with the default behavior. Here's the behavior:\n\nSince there's not a reliable way to do non-blocking DNS without a ton of risky work that would need years of testing on every Unix system in existence, we work around it by doing a threaded implementation.\n\nWhen you request an address, it checks the cache. If the entry isn't in the cache it creates a new one. Each entry has a potentially short lived back-ground thread based on ttl for the records. Once we've populated the cache and you keep the resolver active, the resolution callback will be invoked immediately. When it's idle, it will take a little while in the background thread to fetch more, evaluate TTLs etc... In that case your callback will be invoked from the background thread.\n\n\n\nA few things to note about TTLs and connection failures.\n\nWe attempt to honor your max ttl but will not honor it if dns queries are failing or all of your connections are marked as failed. Once we are able to query dns again, we will re-evaluate the TTLs.\n\nUpon notification connection failures, we move them to a separate list. Eventually we retry them when it's likely that the endpoint is healthy again or we don't really have another choice, but we try to keep them out of your hot path.\n\n\n\nFinally, this entire design attempts to prevent problems where developers have to choose between large TTLs and thus sticky hosts or short TTLs and good fleet utilization but now higher latencies. In this design, we resolve every second in the background (only while you're actually using the record), but we do not expire the earlier resolved addresses until max ttl has passed.\n\nThis for example, should enable you to hit thousands of hosts in the Amazon S3 fleet instead of just one or two.\n\nPrototype\n\nstruct aws_host_resolver *aws_host_resolver_new_default( struct aws_allocator *allocator, const struct aws_host_resolver_default_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_purge_cache-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_purge_cache","text":"aws_host_resolver_purge_cache(resolver)\n\ncompat: Deprecated\nUse purge_cache_with_callback instead calls purge_cache on the vtable.\n\nPrototype\n\nint aws_host_resolver_purge_cache(struct aws_host_resolver *resolver);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_purge_cache_with_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_purge_cache_with_callback","text":"aws_host_resolver_purge_cache_with_callback(resolver, on_purge_cache_complete_callback, user_data)\n\nCalls aws_host_resolver_purge_cache_with_callback on the vtable which will wipe out everything host resolver has cached.\n\nPrototype\n\nint aws_host_resolver_purge_cache_with_callback( struct aws_host_resolver *resolver, aws_simple_completion_callback *on_purge_cache_complete_callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_purge_host_cache-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_purge_host_cache","text":"aws_host_resolver_purge_host_cache(resolver, options)\n\nRemoves the cache for a host asynchronously.\n\nPrototype\n\nint aws_host_resolver_purge_host_cache( struct aws_host_resolver *resolver, const struct aws_host_resolver_purge_host_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_record_connection_failure-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_record_connection_failure","text":"aws_host_resolver_record_connection_failure(resolver, address)\n\ncalls record_connection_failure on the vtable.\n\nPrototype\n\nint aws_host_resolver_record_connection_failure( struct aws_host_resolver *resolver, const struct aws_host_address *address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_release","text":"aws_host_resolver_release(resolver)\n\nDecrements a host resolver's ref count. When the ref count drops to zero, the resolver will be destroyed.\n\nPrototype\n\nvoid aws_host_resolver_release(struct aws_host_resolver *resolver);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_host_resolver_resolve_host-NTuple{5, Any}","page":"Home","title":"LibAwsIO.aws_host_resolver_resolve_host","text":"aws_host_resolver_resolve_host(resolver, host_name, res, config, user_data)\n\ncalls resolve_host on the vtable. config will be copied.\n\nPrototype\n\nint aws_host_resolver_resolve_host( struct aws_host_resolver *resolver, const struct aws_string *host_name, aws_on_host_resolved_result_fn *res, const struct aws_host_resolution_config *config, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_input_stream_acquire","text":"aws_input_stream_acquire(stream)\n\nIncrements the reference count on the input stream, allowing the caller to take a reference to it.\n\nReturns the same input stream passed in.\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_acquire(struct aws_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_input_stream_destroy","text":"aws_input_stream_destroy(stream)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_input_stream_destroy(struct aws_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_get_length-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_get_length","text":"aws_input_stream_get_length(stream, out_length)\n\nDocumentation not found.\n\nPrototype\n\nint aws_input_stream_get_length(struct aws_input_stream *stream, int64_t *out_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_get_status-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_get_status","text":"aws_input_stream_get_status(stream, status)\n\nDocumentation not found.\n\nPrototype\n\nint aws_input_stream_get_status(struct aws_input_stream *stream, struct aws_stream_status *status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_new_from_cursor-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_new_from_cursor","text":"aws_input_stream_new_from_cursor(allocator, cursor)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_new_from_cursor( struct aws_allocator *allocator, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_new_from_file-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_new_from_file","text":"aws_input_stream_new_from_file(allocator, file_name)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_new_from_file( struct aws_allocator *allocator, const char *file_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_new_from_open_file-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_new_from_open_file","text":"aws_input_stream_new_from_open_file(allocator, file)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_new_from_open_file(struct aws_allocator *allocator, FILE *file);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_new_tester-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_new_tester","text":"aws_input_stream_new_tester(alloc, options)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline struct aws_input_stream *aws_input_stream_new_tester( struct aws_allocator *alloc, const struct aws_input_stream_tester_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_read-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_read","text":"aws_input_stream_read(stream, dest)\n\nDocumentation not found.\n\nPrototype\n\nint aws_input_stream_read(struct aws_input_stream *stream, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_input_stream_release","text":"aws_input_stream_release(stream)\n\nDecrements a input stream's ref count. When the ref count drops to zero, the input stream will be destroyed.\n\nReturns NULL always.\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_release(struct aws_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_seek-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_input_stream_seek","text":"aws_input_stream_seek(stream, offset, basis)\n\nDocumentation not found.\n\nPrototype\n\nint aws_input_stream_seek(struct aws_input_stream *stream, int64_t offset, enum aws_stream_seek_basis basis);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_input_stream_tester_total_bytes_read-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_input_stream_tester_total_bytes_read","text":"aws_input_stream_tester_total_bytes_read(stream)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline uint64_t aws_input_stream_tester_total_bytes_read(const struct aws_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_io_fatal_assert_library_initialized-Tuple{}","page":"Home","title":"LibAwsIO.aws_io_fatal_assert_library_initialized","text":"aws_io_fatal_assert_library_initialized()\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_io_fatal_assert_library_initialized(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_io_library_clean_up-Tuple{}","page":"Home","title":"LibAwsIO.aws_io_library_clean_up","text":"aws_io_library_clean_up()\n\nShuts down the internal datastructures used by aws-c-io.\n\nPrototype\n\nvoid aws_io_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_io_library_init-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_io_library_init","text":"aws_io_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-io. Must be called before using any functionality in aws-c-io.\n\nPrototype\n\nvoid aws_io_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_memory_pool_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_memory_pool_acquire","text":"aws_memory_pool_acquire(mempool)\n\nAcquires memory from the pool if available, otherwise, it attempts to allocate and returns the result.\n\nPrototype\n\nvoid *aws_memory_pool_acquire(struct aws_memory_pool *mempool);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_memory_pool_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_memory_pool_clean_up","text":"aws_memory_pool_clean_up(mempool)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_memory_pool_clean_up(struct aws_memory_pool *mempool);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_memory_pool_init-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_memory_pool_init","text":"aws_memory_pool_init(mempool, alloc, ideal_segment_count, segment_size)\n\nDocumentation not found.\n\nPrototype\n\nint aws_memory_pool_init( struct aws_memory_pool *mempool, struct aws_allocator *alloc, uint16_t ideal_segment_count, size_t segment_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_memory_pool_release-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_memory_pool_release","text":"aws_memory_pool_release(mempool, to_release)\n\nReleases memory to the pool if space is available, otherwise frees to_release\n\nPrototype\n\nvoid aws_memory_pool_release(struct aws_memory_pool *mempool, void *to_release);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_message_pool_acquire-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_message_pool_acquire","text":"aws_message_pool_acquire(msg_pool, message_type, size_hint)\n\nAcquires a message from the pool if available, otherwise, it attempts to allocate. If a message is acquired, note that size_hint is just a hint. the return value's capacity will be set to the actual buffer size.\n\nPrototype\n\nstruct aws_io_message *aws_message_pool_acquire( struct aws_message_pool *msg_pool, enum aws_io_message_type message_type, size_t size_hint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_message_pool_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_message_pool_clean_up","text":"aws_message_pool_clean_up(msg_pool)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_message_pool_clean_up(struct aws_message_pool *msg_pool);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_message_pool_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_message_pool_init","text":"aws_message_pool_init(msg_pool, alloc, args)\n\nInitializes message pool using 'msg_pool' as the backing pool, 'args' is copied.\n\nPrototype\n\nint aws_message_pool_init( struct aws_message_pool *msg_pool, struct aws_allocator *alloc, struct aws_message_pool_creation_args *args);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_message_pool_release-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_message_pool_release","text":"aws_message_pool_release(msg_pool, message)\n\nReleases message to the pool if space is available, otherwise frees message\n\nArguments\n\nmessage:\n\nPrototype\n\nvoid aws_message_pool_release(struct aws_message_pool *msg_pool, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pem_objects_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pem_objects_clean_up","text":"aws_pem_objects_clean_up(pem_objects)\n\nCleans up elements of pem_objects list 'aws_pem_objects_init_from_file_contents()' and 'aws_pem_objects_init_from_file_path()'.\n\nPrototype\n\nvoid aws_pem_objects_clean_up(struct aws_array_list *pem_objects);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pem_objects_init_from_file_contents-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_pem_objects_init_from_file_contents","text":"aws_pem_objects_init_from_file_contents(pem_objects, alloc, pem_cursor)\n\nDecodes PEM data and reads objects sequentially adding them to pem_objects. If it comes across an object it cannot read, list of all object read until that point is returned. If no objects can be read from PEM or objects could not be base 64 decoded, AWS_ERROR_PEM_MALFORMED is raised. out_pem_objects stores aws_pem_object struct by value. Function will initialize pem_objects list. This code is slow, and it allocates, so please try not to call this in the middle of something that needs to be fast or resource sensitive.\n\nPrototype\n\nint aws_pem_objects_init_from_file_contents( struct aws_array_list *pem_objects, struct aws_allocator *alloc, struct aws_byte_cursor pem_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pem_objects_init_from_file_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_pem_objects_init_from_file_path","text":"aws_pem_objects_init_from_file_path(pem_objects, allocator, filename)\n\nDecodes PEM data from file and reads objects sequentially adding them to pem_objects. If it comes across an object it cannot read, list of all object read until that point is returned. If no objects can be read from PEM or objects could not be base 64 decoded, AWS_ERROR_PEM_MALFORMED is raised. out_pem_objects stores aws_pem_object struct by value. Function will initialize pem_objects list. This code is slow, and it allocates, so please try not to call this in the middle of something that needs to be fast or resource sensitive.\n\nPrototype\n\nint aws_pem_objects_init_from_file_path( struct aws_array_list *pem_objects, struct aws_allocator *allocator, const char *filename);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_clean_up_read_end-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pipe_clean_up_read_end","text":"aws_pipe_clean_up_read_end(read_end)\n\nClean up the read-end of the pipe. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_clean_up_read_end(struct aws_pipe_read_end *read_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_clean_up_write_end-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pipe_clean_up_write_end","text":"aws_pipe_clean_up_write_end(write_end)\n\nClean up the write-end of the pipe. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_clean_up_write_end(struct aws_pipe_write_end *write_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_get_read_end_event_loop-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pipe_get_read_end_event_loop","text":"aws_pipe_get_read_end_event_loop(read_end)\n\nGet the event-loop connected to the read-end of the pipe. This may be called on any thread.\n\nPrototype\n\nstruct aws_event_loop *aws_pipe_get_read_end_event_loop(const struct aws_pipe_read_end *read_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_get_write_end_event_loop-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pipe_get_write_end_event_loop","text":"aws_pipe_get_write_end_event_loop(write_end)\n\nGet the event-loop connected to the write-end of the pipe. This may be called on any thread.\n\nPrototype\n\nstruct aws_event_loop *aws_pipe_get_write_end_event_loop(const struct aws_pipe_write_end *write_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_init-NTuple{5, Any}","page":"Home","title":"LibAwsIO.aws_pipe_init","text":"aws_pipe_init(read_end, read_end_event_loop, write_end, write_end_event_loop, allocator)\n\nOpens an OS specific bidirectional pipe. The read direction is stored in read_end. Write direction is stored in write_end. Each end must be connected to an event-loop, and further calls to each end must happen on that event-loop's thread.\n\nPrototype\n\nint aws_pipe_init( struct aws_pipe_read_end *read_end, struct aws_event_loop *read_end_event_loop, struct aws_pipe_write_end *write_end, struct aws_event_loop *write_end_event_loop, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_read-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_pipe_read","text":"aws_pipe_read(read_end, dst_buffer, num_bytes_read)\n\nRead data from the pipe into the destination buffer. Attempts to read enough to fill all remaining space in the buffer, from dst\\_buffer->len to dst\\_buffer->capacity. dst\\_buffer->len is updated to reflect the buffer's new length. num_bytes_read (optional) is set to the total number of bytes read. This function never blocks. If no bytes could be read without blocking, then AWS_OP_ERR is returned and aws_last_error() code will be AWS_IO_READ_WOULD_BLOCK. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_read(struct aws_pipe_read_end *read_end, struct aws_byte_buf *dst_buffer, size_t *num_bytes_read);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_subscribe_to_readable_events-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_pipe_subscribe_to_readable_events","text":"aws_pipe_subscribe_to_readable_events(read_end, on_readable, user_data)\n\nSubscribe to be notified when the pipe becomes readable (edge-triggered), or an error occurs. on_readable is invoked on the event-loop's thread when the pipe has data to read, or the pipe has an error. on_readable is invoked again any time the user reads all data, and then more data arrives. Note that it will not be invoked again if the pipe still has unread data when more data arrives. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_subscribe_to_readable_events( struct aws_pipe_read_end *read_end, aws_pipe_on_readable_fn *on_readable, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_unsubscribe_from_readable_events-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pipe_unsubscribe_from_readable_events","text":"aws_pipe_unsubscribe_from_readable_events(read_end)\n\nStop receiving notifications about events on the read-end of the pipe. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_unsubscribe_from_readable_events(struct aws_pipe_read_end *read_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pipe_write-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_pipe_write","text":"aws_pipe_write(write_end, src_buffer, on_completed, user_data)\n\nInitiates an asynchrous write from the source buffer to the pipe. The data referenced by src_buffer must remain in memory until the operation completes. on_complete is called on the event-loop thread when the operation has either completed or failed. The callback's pipe argument will be NULL if the callback is invoked after the pipe has been cleaned up. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_write( struct aws_pipe_write_end *write_end, struct aws_byte_cursor src_buffer, aws_pipe_on_write_completed_fn *on_completed, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pkcs11_lib_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pkcs11_lib_acquire","text":"aws_pkcs11_lib_acquire(pkcs11_lib)\n\nAcquire a reference to a PKCS#11 library, preventing it from being cleaned up. You must call aws_pkcs11_lib_release() when you are done with it. This function returns whatever was passed in. It cannot fail.\n\nPrototype\n\nstruct aws_pkcs11_lib *aws_pkcs11_lib_acquire(struct aws_pkcs11_lib *pkcs11_lib);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pkcs11_lib_new-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_pkcs11_lib_new","text":"aws_pkcs11_lib_new(allocator, options)\n\nLoad and initialize a PKCS#11 library. See aws_pkcs11_lib_options for options.\n\nIf successful a valid pointer is returned. You must call aws_pkcs11_lib_release() when you are done with it. If unsuccessful, NULL is returned and an error is set.\n\nPrototype\n\nstruct aws_pkcs11_lib *aws_pkcs11_lib_new( struct aws_allocator *allocator, const struct aws_pkcs11_lib_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_pkcs11_lib_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_pkcs11_lib_release","text":"aws_pkcs11_lib_release(pkcs11_lib)\n\nRelease a reference to the PKCS#11 library. When the last reference is released, the library is cleaned up.\n\nPrototype\n\nvoid aws_pkcs11_lib_release(struct aws_pkcs11_lib *pkcs11_lib);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_strategy_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_retry_strategy_acquire","text":"aws_retry_strategy_acquire(retry_strategy)\n\nAcquire a reference count on retry_strategy.\n\nPrototype\n\nvoid aws_retry_strategy_acquire(struct aws_retry_strategy *retry_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_strategy_acquire_retry_token-NTuple{5, Any}","page":"Home","title":"LibAwsIO.aws_retry_strategy_acquire_retry_token","text":"aws_retry_strategy_acquire_retry_token(retry_strategy, partition_id, on_acquired, user_data, timeout_ms)\n\nAttempts to acquire a retry token for use with retries. On success, on_acquired will be invoked when a token is available, or an error will be returned if the timeout expires. partition_id identifies operations that should be grouped together. This allows for more sophisticated strategies such as AIMD and circuit breaker patterns. Pass NULL to use the global partition.\n\nPrototype\n\nint aws_retry_strategy_acquire_retry_token( struct aws_retry_strategy *retry_strategy, const struct aws_byte_cursor *partition_id, aws_retry_strategy_on_retry_token_acquired_fn *on_acquired, void *user_data, uint64_t timeout_ms);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_strategy_new_exponential_backoff-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_retry_strategy_new_exponential_backoff","text":"aws_retry_strategy_new_exponential_backoff(allocator, config)\n\nCreates a retry strategy using exponential backoff. This strategy does not perform any bookkeeping on error types and success. There is no circuit breaker functionality in here. See the comments above for aws_exponential_backoff_retry_options.\n\nPrototype\n\nstruct aws_retry_strategy *aws_retry_strategy_new_exponential_backoff( struct aws_allocator *allocator, const struct aws_exponential_backoff_retry_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_strategy_new_standard-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_retry_strategy_new_standard","text":"aws_retry_strategy_new_standard(allocator, config)\n\nThis is a retry implementation that cuts off traffic if it's detected that an endpoint partition is having availability problems. This is necessary to keep from making outages worse by scheduling work that's unlikely to succeed yet increases load on an already ailing system.\n\nWe do this by creating a bucket for each partition. A partition is an arbitrary specifier. It can be anything: a region, a service, a combination of region and service, a literal dns name.... doesn't matter.\n\nEach bucket has a budget for maximum allowed retries. Different types of events carry different weights. Things that indicate an unhealthy partition such as transient errors (timeouts, unhealthy connection etc...) cost more. A retry for any other reason (service sending a 5xx response code) cost a bit less. When a retry is attempted this capacity is leased out to the retry. On success it is released back to the capacity pool. On failure, it remains leased. Operations that succeed without a retry slowly restore the capacity pool.\n\nIf a partition runs out of capacity it is assumed unhealthy and retries will be blocked until capacity returns to the pool. To prevent a partition from staying unhealthy after an outage has recovered, new requests that succeed without a retry will increase the capacity slowly ( a new request gets a payback lease of 1, but the lease is never actually deducted from the capacity pool).\n\nPrototype\n\nstruct aws_retry_strategy *aws_retry_strategy_new_standard( struct aws_allocator *allocator, const struct aws_standard_retry_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_strategy_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_retry_strategy_release","text":"aws_retry_strategy_release(retry_strategy)\n\nReleases a reference count on retry_strategy.\n\nPrototype\n\nvoid aws_retry_strategy_release(struct aws_retry_strategy *retry_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_strategy_schedule_retry-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_retry_strategy_schedule_retry","text":"aws_retry_strategy_schedule_retry(token, error_type, retry_ready, user_data)\n\nSchedules a retry based on the backoff and token based strategies. retry_ready is invoked when the retry is either ready for execution or if it has been canceled due to application shutdown.\n\nThis function can return an error to reject the retry attempt if, for example, a circuit breaker has opened. If this occurs users should fail their calls back to their callers.\n\nerror_type is used for book keeping. See the comments above for aws_retry_error_type.\n\nPrototype\n\nint aws_retry_strategy_schedule_retry( struct aws_retry_token *token, enum aws_retry_error_type error_type, aws_retry_strategy_on_retry_ready_fn *retry_ready, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_token_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_retry_token_acquire","text":"aws_retry_token_acquire(token)\n\nIncrements reference count for token. This should be called any time you seat the token to a pointer you own.\n\nPrototype\n\nvoid aws_retry_token_acquire(struct aws_retry_token *token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_token_record_success-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_retry_token_record_success","text":"aws_retry_token_record_success(token)\n\nRecords a successful retry. This is used for making future decisions to open up token buckets, AIMD breakers etc... some strategies such as exponential backoff will ignore this, but you should always call it after a successful operation or your system will never recover during an outage.\n\nPrototype\n\nint aws_retry_token_record_success(struct aws_retry_token *token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_retry_token_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_retry_token_release","text":"aws_retry_token_release(token)\n\nReleases the reference count for token. This should always be invoked after either calling aws_retry_strategy_schedule_retry() and failing, or after calling aws_retry_token_record_success().\n\nPrototype\n\nvoid aws_retry_token_release(struct aws_retry_token *token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_server_bootstrap_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_server_bootstrap_acquire","text":"aws_server_bootstrap_acquire(bootstrap)\n\nIncrements a server bootstrap's ref count, allowing the caller to take a reference to it.\n\nReturns the same server bootstrap passed in.\n\nPrototype\n\nstruct aws_server_bootstrap *aws_server_bootstrap_acquire(struct aws_server_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_server_bootstrap_destroy_socket_listener-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_server_bootstrap_destroy_socket_listener","text":"aws_server_bootstrap_destroy_socket_listener(bootstrap, listener)\n\nShuts down 'listener' and cleans up any resources associated with it. Any incoming channels on listener will still be active. destroy_callback will be invoked after the server socket listener is destroyed, and all associated connections and channels have finished shutting down.\n\nPrototype\n\nvoid aws_server_bootstrap_destroy_socket_listener( struct aws_server_bootstrap *bootstrap, struct aws_socket *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_server_bootstrap_new-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_server_bootstrap_new","text":"aws_server_bootstrap_new(allocator, el_group)\n\nInitializes the server bootstrap with allocator and el_group. This object manages listeners, server connections, and channels.\n\nPrototype\n\nstruct aws_server_bootstrap *aws_server_bootstrap_new( struct aws_allocator *allocator, struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_server_bootstrap_new_socket_listener-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_server_bootstrap_new_socket_listener","text":"aws_server_bootstrap_new_socket_listener(bootstrap_options)\n\nSets up a server socket listener. If you are planning on using TLS, use aws_server_bootstrap_new_tls_socket_listener instead. This creates a socket listener bound to local_endpoint using socket options options. incoming_callback will be invoked once an incoming channel is ready for use or if an error is encountered. shutdown_callback will be invoked once the channel has shutdown. destroy_callback will be invoked after the server socket listener is destroyed, and all associated connections and channels have finished shutting down. Immediately after the shutdown_callback returns, the channel is cleaned up automatically. All callbacks are invoked the thread of the event-loop that the listening socket is assigned to\n\nUpon shutdown of your application, you'll want to call aws_server_bootstrap_destroy_socket_listener with the return value from this function.\n\nbootstrap_options is copied.\n\nPrototype\n\nstruct aws_socket *aws_server_bootstrap_new_socket_listener( const struct aws_server_socket_channel_bootstrap_options *bootstrap_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_server_bootstrap_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_server_bootstrap_release","text":"aws_server_bootstrap_release(bootstrap)\n\nDecrements a server bootstrap's ref count. When the ref count drops to zero, the bootstrap will be destroyed.\n\nPrototype\n\nvoid aws_server_bootstrap_release(struct aws_server_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_server_bootstrap_set_alpn_callback-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_server_bootstrap_set_alpn_callback","text":"aws_server_bootstrap_set_alpn_callback(bootstrap, on_protocol_negotiated)\n\nWhen using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added to the channel.\n\nPrototype\n\nint aws_server_bootstrap_set_alpn_callback( struct aws_server_bootstrap *bootstrap, aws_channel_on_protocol_negotiated_fn *on_protocol_negotiated);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_shared_library_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_shared_library_clean_up","text":"aws_shared_library_clean_up(library)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_shared_library_clean_up(struct aws_shared_library *library);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_shared_library_find_function-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_shared_library_find_function","text":"aws_shared_library_find_function(library, symbol_name, function_address)\n\nDocumentation not found.\n\nPrototype\n\nint aws_shared_library_find_function( struct aws_shared_library *library, const char *symbol_name, aws_generic_function *function_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_shared_library_init-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_shared_library_init","text":"aws_shared_library_init(library, library_path)\n\nDocumentation not found.\n\nPrototype\n\nint aws_shared_library_init(struct aws_shared_library *library, const char *library_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_assign_to_event_loop-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_assign_to_event_loop","text":"aws_socket_assign_to_event_loop(socket, event_loop)\n\nAssigns the socket to the event-loop. The socket will begin receiving read/write/error notifications after this call.\n\nNote: If you called connect for TCP or Unix Domain Sockets and received a connection_success callback, this has already happened. You only need to call this function when:\n\na.) This socket is a server socket (e.g. a result of a call to start_accept()) b.) This socket is a UDP socket.\n\nPrototype\n\nint aws_socket_assign_to_event_loop(struct aws_socket *socket, struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_bind-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_bind","text":"aws_socket_bind(socket, local_endpoint)\n\nBinds the socket to a local address. In UDP mode, the socket is ready for [awssocketread](@ref)() operations. In connection oriented modes, you still must call [awssocketlisten](@ref)() and [awssocketstartaccept](@ref)() before using the socket. local\\endpoint is copied.\n\nPrototype\n\nint aws_socket_bind(struct aws_socket *socket, const struct aws_socket_endpoint *local_endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_clean_up","text":"aws_socket_clean_up(socket)\n\nShuts down any pending operations on the socket, and cleans up state. The socket object can be re-initialized after this operation. This function calls aws_socket_close. If you have not already called aws_socket_close() on the socket, all of the rules for aws_socket_close() apply here. In this case it will not fail if you use the function improperly, but on some platforms you will certainly leak memory.\n\nIf the socket has already been closed, you can safely, call this from any thread.\n\nPrototype\n\nvoid aws_socket_clean_up(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_close-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_close","text":"aws_socket_close(socket)\n\nCalls close() on the socket and unregisters all io operations from the event loop. This function must be called from the event-loop's thread unless this is a listening socket. If it's a listening socket it can be called from any non-event-loop thread or the event-loop the socket is currently assigned to. If called from outside the event-loop, this function will block waiting on the socket to close. If this is called from an event-loop thread other than the one it's assigned to, it presents the possibility of a deadlock, so don't do it.\n\nPrototype\n\nint aws_socket_close(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_connect-NTuple{5, Any}","page":"Home","title":"LibAwsIO.aws_socket_connect","text":"aws_socket_connect(socket, remote_endpoint, event_loop, on_connection_result, user_data)\n\nConnects to a remote endpoint. In UDP, this simply binds the socket to a remote address for use with [awssocketwrite](@ref)(), and if the operation is successful, the socket can immediately be used for write operations.\n\nIn TCP, LOCAL and VSOCK this function will not block. If the return value is successful, then you must wait on the on\\_connection\\_result() callback to be invoked before using the socket.\n\nIf an event_loop is provided for UDP sockets, a notification will be sent on on_connection_result in the event-loop's thread. Upon completion, the socket will already be assigned an event loop. If NULL is passed for UDP, it will immediately return upon success, but you must call aws_socket_assign_to_event_loop before use.\n\nPrototype\n\nint aws_socket_connect( struct aws_socket *socket, const struct aws_socket_endpoint *remote_endpoint, struct aws_event_loop *event_loop, aws_socket_on_connection_result_fn *on_connection_result, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_endpoint_init_local_address_for_test-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_endpoint_init_local_address_for_test","text":"aws_socket_endpoint_init_local_address_for_test(endpoint)\n\nAssigns a random address (UUID) for use with AWS_SOCKET_LOCAL (Unix Domain Sockets). For use in internal tests only.\n\nPrototype\n\nvoid aws_socket_endpoint_init_local_address_for_test(struct aws_socket_endpoint *endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_get_bound_address-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_get_bound_address","text":"aws_socket_get_bound_address(socket, out_address)\n\nGet the local address which the socket is bound to. Raises an error if no address is bound.\n\nPrototype\n\nint aws_socket_get_bound_address(const struct aws_socket *socket, struct aws_socket_endpoint *out_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_get_error-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_get_error","text":"aws_socket_get_error(socket)\n\nGets the latest error from the socket. If no error has occurred AWS_OP_SUCCESS will be returned. This function does not raise any errors to the installed error handlers.\n\nPrototype\n\nint aws_socket_get_error(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_get_event_loop-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_get_event_loop","text":"aws_socket_get_event_loop(socket)\n\nGets the event-loop the socket is assigned to.\n\nPrototype\n\nstruct aws_event_loop *aws_socket_get_event_loop(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_handler_get_socket-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_handler_get_socket","text":"aws_socket_handler_get_socket(handler)\n\nDocumentation not found.\n\nPrototype\n\nconst struct aws_socket *aws_socket_handler_get_socket(const struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_handler_new-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_socket_handler_new","text":"aws_socket_handler_new(allocator, socket, slot, max_read_size)\n\nSocket handlers should be the first slot/handler in a channel. It interacts directly with the channel's event loop for read and write notifications. max_read_size is the maximum amount of data it will read from the socket before a context switch (a continuation task will be scheduled).\n\nPrototype\n\nstruct aws_channel_handler *aws_socket_handler_new( struct aws_allocator *allocator, struct aws_socket *socket, struct aws_channel_slot *slot, size_t max_read_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_init","text":"aws_socket_init(socket, alloc, options)\n\nInitializes a socket object with socket options. options will be copied.\n\nPrototype\n\nint aws_socket_init( struct aws_socket *socket, struct aws_allocator *alloc, const struct aws_socket_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_is_open-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_is_open","text":"aws_socket_is_open(socket)\n\nReturns true if the socket is still open (doesn't mean connected or listening, only that it hasn't had close() called.\n\nPrototype\n\nbool aws_socket_is_open(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_listen-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_listen","text":"aws_socket_listen(socket, backlog_size)\n\nTCP, LOCAL and VSOCK only. Sets up the socket to listen on the address bound to in [awssocketbind](@ref)().\n\nPrototype\n\nint aws_socket_listen(struct aws_socket *socket, int backlog_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_read-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_read","text":"aws_socket_read(socket, buffer, amount_read)\n\nReads from the socket. This call is non-blocking and will return AWS_IO_SOCKET_READ_WOULD_BLOCK if no data is available. read is the amount of data read into buffer.\n\nAttempts to read enough to fill all remaining space in the buffer, from buffer->len to buffer->capacity. buffer->len is updated to reflect the buffer's new length.\n\nUse aws_socket_subscribe_to_readable_events() to receive notifications of when the socket goes readable.\n\nNOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop\n\nPrototype\n\nint aws_socket_read(struct aws_socket *socket, struct aws_byte_buf *buffer, size_t *amount_read);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_set_options-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_set_options","text":"aws_socket_set_options(socket, options)\n\nSets new socket options on the underlying socket. This is mainly useful in context of accepting a new connection via: on\\_incoming\\_connection(). options is copied.\n\nPrototype\n\nint aws_socket_set_options(struct aws_socket *socket, const struct aws_socket_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_shutdown_dir-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_shutdown_dir","text":"aws_socket_shutdown_dir(socket, dir)\n\nCalls shutdown() on the socket based on direction.\n\nPrototype\n\nint aws_socket_shutdown_dir(struct aws_socket *socket, enum aws_channel_direction dir);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_start_accept-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_socket_start_accept","text":"aws_socket_start_accept(socket, accept_loop, on_accept_result, user_data)\n\nTCP, LOCAL and VSOCK only. The socket will begin accepting new connections. This is an asynchronous operation. New connections or errors will arrive via the on_accept_result callback.\n\naws_socket_bind() and aws_socket_listen() must be called before calling this function.\n\nPrototype\n\nint aws_socket_start_accept( struct aws_socket *socket, struct aws_event_loop *accept_loop, aws_socket_on_accept_result_fn *on_accept_result, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_stop_accept-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_socket_stop_accept","text":"aws_socket_stop_accept(socket)\n\nTCP, LOCAL and VSOCK only. The listening socket will stop accepting new connections. It is safe to call [awssocketstart_accept](@ref)() again after this operation. This can be called from any thread but be aware, on some platforms, if you call this from outside of the current event loop's thread, it will block until the event loop finishes processing the request for unsubscribe in it's own thread.\n\nPrototype\n\nint aws_socket_stop_accept(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_subscribe_to_readable_events-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_subscribe_to_readable_events","text":"aws_socket_subscribe_to_readable_events(socket, on_readable, user_data)\n\nSubscribes on_readable to notifications when the socket goes readable (edge-triggered). Errors will also be recieved in the callback.\n\nNote! This function is technically not thread safe, but we do not enforce which thread you call from. It's your responsibility to either call this in safely (e.g. just don't call it in parallel from multiple threads) or schedule a task to call it. If you call it before your first call to read, it will be fine.\n\nPrototype\n\nint aws_socket_subscribe_to_readable_events( struct aws_socket *socket, aws_socket_on_readable_fn *on_readable, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_validate_port_for_bind-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_validate_port_for_bind","text":"aws_socket_validate_port_for_bind(port, domain)\n\nRaises AWS_IO_SOCKET_INVALID_ADDRESS and logs an error if binding to this port is illegal. For example, port must in range 0-65535 to bind with IPv4. These port values would fail eventually in aws_socket_bind(), but you can use this function to validate earlier.\n\nPrototype\n\nint aws_socket_validate_port_for_bind(uint32_t port, enum aws_socket_domain domain);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_validate_port_for_connect-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_socket_validate_port_for_connect","text":"aws_socket_validate_port_for_connect(port, domain)\n\nRaises AWS_IO_SOCKET_INVALID_ADDRESS and logs an error if connecting to this port is illegal. For example, port must be in range 1-65535 to connect with IPv4. These port values would fail eventually in aws_socket_connect(), but you can use this function to validate earlier.\n\nPrototype\n\nint aws_socket_validate_port_for_connect(uint32_t port, enum aws_socket_domain domain);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_socket_write-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_socket_write","text":"aws_socket_write(socket, cursor, written_fn, user_data)\n\nWrites to the socket. This call is non-blocking and will attempt to write as much as it can, but will queue any remaining portion of the data for write when available. written_fn will be invoked once the entire cursor has been written, or the write failed or was cancelled.\n\nNOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop\n\nFor client sockets, connect() and aws_socket_assign_to_event_loop() must be called before calling this.\n\nFor incoming sockets from a listener, aws_socket_assign_to_event_loop() must be called first.\n\nPrototype\n\nint aws_socket_write( struct aws_socket *socket, const struct aws_byte_cursor *cursor, aws_socket_on_write_completed_fn *written_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_alpn_handler_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_alpn_handler_new","text":"aws_tls_alpn_handler_new(allocator, on_protocol_negotiated, user_data)\n\nCreates a channel handler, for client or server mode, that handles alpn. This isn't necessarily required since you can always call aws_tls_handler_protocol in the aws_tls_on_negotiation_result_fn callback, but this makes channel bootstrap easier to handle.\n\nPrototype\n\nstruct aws_channel_handler *aws_tls_alpn_handler_new( struct aws_allocator *allocator, aws_tls_on_protocol_negotiated on_protocol_negotiated, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_client_ctx_new-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_client_ctx_new","text":"aws_tls_client_ctx_new(alloc, options)\n\nCreates a new client ctx. This ctx can be used for the lifetime of the application assuming you want the same options for every outgoing connection. Options will be copied.\n\nPrototype\n\nstruct aws_tls_ctx *aws_tls_client_ctx_new( struct aws_allocator *alloc, const struct aws_tls_ctx_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_client_handler_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_client_handler_new","text":"aws_tls_client_handler_new(allocator, options, slot)\n\nCreates a new tls channel handler in client mode. Options will be copied. You must call aws_tls_client_handler_start_negotiation and wait on the aws_tls_on_negotiation_result_fn callback before the handler can begin processing application data.\n\nPrototype\n\nstruct aws_channel_handler *aws_tls_client_handler_new( struct aws_allocator *allocator, struct aws_tls_connection_options *options, struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_client_handler_start_negotiation-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_client_handler_start_negotiation","text":"aws_tls_client_handler_start_negotiation(handler)\n\nKicks off the negotiation process. This function must be called when in client mode to initiate the TLS handshake. Once the handshake has completed the aws_tls_on_negotiation_result_fn will be invoked.\n\nPrototype\n\nint aws_tls_client_handler_start_negotiation(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_connection_options_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_connection_options_clean_up","text":"aws_tls_connection_options_clean_up(connection_options)\n\nCleans up resources in aws_tls_connection_options. This can be called immediately after initializing a tls handler, or if using the bootstrap api, immediately after asking for a channel.\n\nPrototype\n\nvoid aws_tls_connection_options_clean_up(struct aws_tls_connection_options *connection_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_connection_options_copy-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_connection_options_copy","text":"aws_tls_connection_options_copy(to, from)\n\nCopies 'from' to 'to'\n\nPrototype\n\nint aws_tls_connection_options_copy( struct aws_tls_connection_options *to, const struct aws_tls_connection_options *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_connection_options_init_from_ctx-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_connection_options_init_from_ctx","text":"aws_tls_connection_options_init_from_ctx(conn_options, ctx)\n\nInitializes default connection options from an instance ot aws_tls_ctx.\n\nPrototype\n\nvoid aws_tls_connection_options_init_from_ctx( struct aws_tls_connection_options *conn_options, struct aws_tls_ctx *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_connection_options_set_alpn_list-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_connection_options_set_alpn_list","text":"aws_tls_connection_options_set_alpn_list(conn_options, allocator, alpn_list)\n\nSets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported. alpn_list is copied. This value is already inherited from aws_tls_ctx, but the aws_tls_ctx is expensive, and should be used across as many connections as possible. If you want to set this per connection, set it here.\n\nPrototype\n\nint aws_tls_connection_options_set_alpn_list( struct aws_tls_connection_options *conn_options, struct aws_allocator *allocator, const char *alpn_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_connection_options_set_callbacks-NTuple{5, Any}","page":"Home","title":"LibAwsIO.aws_tls_connection_options_set_callbacks","text":"aws_tls_connection_options_set_callbacks(conn_options, on_negotiation_result, on_data_read, on_error, user_data)\n\nSets callbacks for use with a tls connection.\n\nPrototype\n\nvoid aws_tls_connection_options_set_callbacks( struct aws_tls_connection_options *conn_options, aws_tls_on_negotiation_result_fn *on_negotiation_result, aws_tls_on_data_read_fn *on_data_read, aws_tls_on_error_fn *on_error, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_connection_options_set_server_name-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_connection_options_set_server_name","text":"aws_tls_connection_options_set_server_name(conn_options, allocator, server_name)\n\nSets server name to use for the SNI extension (supported everywhere), as well as x.509 validation. If you don't set this, your x.509 validation will likely fail.\n\nPrototype\n\nint aws_tls_connection_options_set_server_name( struct aws_tls_connection_options *conn_options, struct aws_allocator *allocator, const struct aws_byte_cursor *server_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_acquire-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_acquire","text":"aws_tls_ctx_acquire(ctx)\n\nIncrements the reference count on the tls context, allowing the caller to take a reference to it.\n\nReturns the same tls context passed in.\n\nPrototype\n\nstruct aws_tls_ctx *aws_tls_ctx_acquire(struct aws_tls_ctx *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_clean_up","text":"aws_tls_ctx_options_clean_up(options)\n\nCleans up resources allocated by init_* functions\n\nPrototype\n\nvoid aws_tls_ctx_options_clean_up(struct aws_tls_ctx_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_client_mtls-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_client_mtls","text":"aws_tls_ctx_options_init_client_mtls(options, allocator, cert, pkey)\n\nInitializes options for use with mutual tls in client mode. cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM armored.\n\nNOTE: This is unsupported on iOS.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const struct aws_byte_cursor *cert, const struct aws_byte_cursor *pkey);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_client_mtls_from_path-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_client_mtls_from_path","text":"aws_tls_ctx_options_init_client_mtls_from_path(options, allocator, cert_path, pkey_path)\n\nInitializes options for use with mutual tls in client mode. cert_path and pkey_path are paths to files on disk. cert_path and pkey_path are treated as PKCS#7 PEM armored. They are loaded from disk and stored in buffers internally.\n\nNOTE: This is unsupported on iOS.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_path, const char *pkey_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_client_mtls_from_system_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_client_mtls_from_system_path","text":"aws_tls_ctx_options_init_client_mtls_from_system_path(options, allocator, cert_reg_path)\n\nInitializes options for use with mutual tls in client mode. cert_reg_path is the path to a system installed certficate/private key pair. Example: CurrentUser\\MY\\<thumprint>\n\nNOTE: This only works on Windows.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_from_system_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_reg_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_client_mtls_pkcs12-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_client_mtls_pkcs12","text":"aws_tls_ctx_options_init_client_mtls_pkcs12(options, allocator, pkcs12, pkcs_pwd)\n\nInitializes options for use with mutual tls in client mode. pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied. pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_pkcs12( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_byte_cursor *pkcs12, struct aws_byte_cursor *pkcs_pwd);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_client_mtls_pkcs12_from_path-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_client_mtls_pkcs12_from_path","text":"aws_tls_ctx_options_init_client_mtls_pkcs12_from_path(options, allocator, pkcs12_path, pkcs_pwd)\n\nInitializes options for use with mutual tls in client mode. pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_pkcs12_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *pkcs12_path, const struct aws_byte_cursor *pkcs_pwd);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_client_mtls_with_custom_key_operations-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_client_mtls_with_custom_key_operations","text":"aws_tls_ctx_options_init_client_mtls_with_custom_key_operations(options, allocator, custom, cert_file_contents)\n\nInitializes options for use with mutual TLS in client mode, where private key operations are handled by custom code.\n\nNote: cert_file_contents will be copied into a new buffer after this function is called, so you do not need to keep that data alive after calling this function.\n\nArguments\n\noptions: aws_tls_ctx_options to be initialized.\nallocator: Allocator to use.\ncustom: Options for custom key operations.\ncert_file_contents: The contents of a certificate file.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_with_custom_key_operations( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_custom_key_op_handler *custom, const struct aws_byte_cursor *cert_file_contents);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_client_mtls_with_pkcs11-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_client_mtls_with_pkcs11","text":"aws_tls_ctx_options_init_client_mtls_with_pkcs11(options, allocator, pkcs11_options)\n\nInitializes options for use with mutual TLS in client mode, where a PKCS#11 library provides access to the private key.\n\nNOTE: This only works on Unix devices.\n\nArguments\n\noptions: aws_tls_ctx_options to be initialized.\nallocator: Allocator to use.\npkcs11_options: Options for using PKCS#11 (contents are copied)\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_with_pkcs11( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const struct aws_tls_ctx_pkcs11_options *pkcs11_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_default_client-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_default_client","text":"aws_tls_ctx_options_init_default_client(options, allocator)\n\n****************************** tls options init stuff **********************\n\nInitializes options with default client options\n\nPrototype\n\nvoid aws_tls_ctx_options_init_default_client( struct aws_tls_ctx_options *options, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_default_server-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_default_server","text":"aws_tls_ctx_options_init_default_server(options, allocator, cert, pkey)\n\nInitializes options for use with in server mode. cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM armored.\n\nPrototype\n\nint aws_tls_ctx_options_init_default_server( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_byte_cursor *cert, struct aws_byte_cursor *pkey);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_default_server_from_path-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_default_server_from_path","text":"aws_tls_ctx_options_init_default_server_from_path(options, allocator, cert_path, pkey_path)\n\nInitializes options for use with in server mode. cert_path and pkey_path are paths to files on disk. cert_path and pkey_path are treated as PKCS#7 PEM armored. They are loaded from disk and stored in buffers internally.\n\nPrototype\n\nint aws_tls_ctx_options_init_default_server_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_path, const char *pkey_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_default_server_from_system_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_default_server_from_system_path","text":"aws_tls_ctx_options_init_default_server_from_system_path(options, allocator, cert_reg_path)\n\nInitializes options for use with server mode. cert_reg_path is the path to a system installed certficate/private key pair. Example: CurrentUser\\MY\\<thumprint>\n\nNOTE: This only works on Windows.\n\nPrototype\n\nint aws_tls_ctx_options_init_default_server_from_system_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_reg_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_server_pkcs12-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_server_pkcs12","text":"aws_tls_ctx_options_init_server_pkcs12(options, allocator, pkcs12, pkcs_password)\n\nInitializes options for use in server mode. pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied. pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_server_pkcs12( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_byte_cursor *pkcs12, struct aws_byte_cursor *pkcs_password);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_init_server_pkcs12_from_path-NTuple{4, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_init_server_pkcs12_from_path","text":"aws_tls_ctx_options_init_server_pkcs12_from_path(options, allocator, pkcs12_path, pkcs_password)\n\nInitializes options for use in server mode. pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_server_pkcs12_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *pkcs12_path, struct aws_byte_cursor *pkcs_password);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_override_default_trust_store-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_override_default_trust_store","text":"aws_tls_ctx_options_override_default_trust_store(options, ca_file)\n\nOverride the default trust store. ca_file is a buffer containing a PEM armored chain of trusted CA certificates. ca_file is copied.\n\nPrototype\n\nint aws_tls_ctx_options_override_default_trust_store( struct aws_tls_ctx_options *options, const struct aws_byte_cursor *ca_file);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_override_default_trust_store_from_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_override_default_trust_store_from_path","text":"aws_tls_ctx_options_override_default_trust_store_from_path(options, ca_path, ca_file)\n\nOverride the default trust store. ca_path is a path to a directory on disk containing trusted certificates. This is only supported on Unix systems (otherwise this parameter is ignored). ca_file is a path to a file on disk containing trusted certificates. ca_file is loaded from disk and stored in an internal buffer.\n\nPrototype\n\nint aws_tls_ctx_options_override_default_trust_store_from_path( struct aws_tls_ctx_options *options, const char *ca_path, const char *ca_file);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_set_alpn_list-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_set_alpn_list","text":"aws_tls_ctx_options_set_alpn_list(options, alpn_list)\n\nSets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported. alpn_list is copied.\n\nPrototype\n\nint aws_tls_ctx_options_set_alpn_list(struct aws_tls_ctx_options *options, const char *alpn_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_set_extension_data-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_set_extension_data","text":"aws_tls_ctx_options_set_extension_data(options, extension_data)\n\nWhen implementing BYO_CRYPTO, if you need extra data to pass to your tls implementation, set it here. The lifetime of extension_data must outlive the options object and be cleaned up after options is cleaned up.\n\nPrototype\n\nvoid aws_tls_ctx_options_set_extension_data(struct aws_tls_ctx_options *options, void *extension_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_set_keychain_path-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_set_keychain_path","text":"aws_tls_ctx_options_set_keychain_path(options, keychain_path_cursor)\n\ncompat: Deprecated\n\n\nSets a custom keychain path for storing the cert and pkey with mutual tls in client mode.\n\nNOTE: This only works on MacOS.\n\nPrototype\n\nint aws_tls_ctx_options_set_keychain_path( struct aws_tls_ctx_options *options, struct aws_byte_cursor *keychain_path_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_set_minimum_tls_version-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_set_minimum_tls_version","text":"aws_tls_ctx_options_set_minimum_tls_version(options, minimum_tls_version)\n\nSets the minimum TLS version to allow.\n\nPrototype\n\nvoid aws_tls_ctx_options_set_minimum_tls_version( struct aws_tls_ctx_options *options, enum aws_tls_versions minimum_tls_version);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_set_tls_cipher_preference-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_set_tls_cipher_preference","text":"aws_tls_ctx_options_set_tls_cipher_preference(options, cipher_pref)\n\nSets preferred TLS Cipher List\n\nPrototype\n\nvoid aws_tls_ctx_options_set_tls_cipher_preference( struct aws_tls_ctx_options *options, enum aws_tls_cipher_pref cipher_pref);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_options_set_verify_peer-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_options_set_verify_peer","text":"aws_tls_ctx_options_set_verify_peer(options, verify_peer)\n\nEnables or disables x.509 validation. Disable this only for testing. To enable mutual TLS in server mode, set verify_peer to true.\n\nPrototype\n\nvoid aws_tls_ctx_options_set_verify_peer(struct aws_tls_ctx_options *options, bool verify_peer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_ctx_release-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_ctx_release","text":"aws_tls_ctx_release(ctx)\n\nDecrements a tls context's ref count. When the ref count drops to zero, the object will be destroyed.\n\nPrototype\n\nvoid aws_tls_ctx_release(struct aws_tls_ctx *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_handler_protocol-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_handler_protocol","text":"aws_tls_handler_protocol(handler)\n\nReturns a byte buffer by copy of the negotiated protocols. If there is no agreed upon protocol, len will be 0 and buffer will be NULL.\n\nPrototype\n\nstruct aws_byte_buf aws_tls_handler_protocol(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_handler_server_name-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_handler_server_name","text":"aws_tls_handler_server_name(handler)\n\nClient mode only. This is the server name that was used for SNI and host name validation.\n\nPrototype\n\nstruct aws_byte_buf aws_tls_handler_server_name(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_hash_algorithm_str-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_hash_algorithm_str","text":"aws_tls_hash_algorithm_str(hash)\n\nGiven enum, return string like: AWS_TLS_HASH_SHA256 -> \"SHA256\"\n\nPrototype\n\nconst char *aws_tls_hash_algorithm_str(enum aws_tls_hash_algorithm hash);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_is_alpn_available-Tuple{}","page":"Home","title":"LibAwsIO.aws_tls_is_alpn_available","text":"aws_tls_is_alpn_available()\n\nReturns true if alpn is available in the underlying tls implementation. This function should always be called before setting an alpn list.\n\nPrototype\n\nbool aws_tls_is_alpn_available(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_is_cipher_pref_supported-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_is_cipher_pref_supported","text":"aws_tls_is_cipher_pref_supported(cipher_pref)\n\nReturns true if this Cipher Preference is available in the underlying TLS implementation. This function should always be called before setting a Cipher Preference\n\nPrototype\n\nbool aws_tls_is_cipher_pref_supported(enum aws_tls_cipher_pref cipher_pref);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_key_operation_complete-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_key_operation_complete","text":"aws_tls_key_operation_complete(operation, output)\n\nComplete a successful TLS private key operation by providing its output. The output is copied into the TLS connection. The operation is freed by this call.\n\nYou MUST call this or aws_tls_key_operation_complete_with_error(). Failure to do so will stall the TLS connection indefinitely and leak memory.\n\nPrototype\n\nvoid aws_tls_key_operation_complete(struct aws_tls_key_operation *operation, struct aws_byte_cursor output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_key_operation_complete_with_error-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_key_operation_complete_with_error","text":"aws_tls_key_operation_complete_with_error(operation, error_code)\n\nComplete an failed TLS private key operation. The TLS connection will fail. The operation is freed by this call.\n\nYou MUST call this or aws_tls_key_operation_complete(). Failure to do so will stall the TLS connection indefinitely and leak memory.\n\nPrototype\n\nvoid aws_tls_key_operation_complete_with_error(struct aws_tls_key_operation *operation, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_key_operation_get_digest_algorithm-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_key_operation_get_digest_algorithm","text":"aws_tls_key_operation_get_digest_algorithm(operation)\n\nReturns the algorithm the operation digest is signed with. If the implementation does not support the digest algorithm, use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection.\n\nPrototype\n\nenum aws_tls_hash_algorithm aws_tls_key_operation_get_digest_algorithm(const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_key_operation_get_input-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_key_operation_get_input","text":"aws_tls_key_operation_get_input(operation)\n\nReturns the input data that needs to be operated on by the custom key operation.\n\nPrototype\n\nstruct aws_byte_cursor aws_tls_key_operation_get_input(const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_key_operation_get_signature_algorithm-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_key_operation_get_signature_algorithm","text":"aws_tls_key_operation_get_signature_algorithm(operation)\n\nReturns the algorithm the operation is expected to be operated with. If the implementation does not support the signature algorithm, use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection.\n\nPrototype\n\nenum aws_tls_signature_algorithm aws_tls_key_operation_get_signature_algorithm( const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_key_operation_get_type-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_key_operation_get_type","text":"aws_tls_key_operation_get_type(operation)\n\nReturns the type of operation that needs to be performed by the custom key operation. If the implementation cannot perform the operation, use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection.\n\nPrototype\n\nenum aws_tls_key_operation_type aws_tls_key_operation_get_type(const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_key_operation_type_str-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_key_operation_type_str","text":"aws_tls_key_operation_type_str(operation_type)\n\nGiven enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\"\n\nPrototype\n\nconst char *aws_tls_key_operation_type_str(enum aws_tls_key_operation_type operation_type);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_server_ctx_new-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_server_ctx_new","text":"aws_tls_server_ctx_new(alloc, options)\n\nCreates a new server ctx. This ctx can be used for the lifetime of the application assuming you want the same options for every incoming connection. Options will be copied.\n\nPrototype\n\nstruct aws_tls_ctx *aws_tls_server_ctx_new( struct aws_allocator *alloc, const struct aws_tls_ctx_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_server_handler_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.aws_tls_server_handler_new","text":"aws_tls_server_handler_new(allocator, options, slot)\n\nCreates a new tls channel handler in server mode. Options will be copied. You must wait on the aws_tls_on_negotiation_result_fn callback before the handler can begin processing application data.\n\nPrototype\n\nstruct aws_channel_handler *aws_tls_server_handler_new( struct aws_allocator *allocator, struct aws_tls_connection_options *options, struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.aws_tls_signature_algorithm_str-Tuple{Any}","page":"Home","title":"LibAwsIO.aws_tls_signature_algorithm_str","text":"aws_tls_signature_algorithm_str(signature)\n\nGiven enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\"\n\nPrototype\n\nconst char *aws_tls_signature_algorithm_str(enum aws_tls_signature_algorithm signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_async_input_stream_tester_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.s_async_input_stream_tester_destroy","text":"s_async_input_stream_tester_destroy(async_stream)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline void s_async_input_stream_tester_destroy(struct aws_async_input_stream *async_stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_async_input_stream_tester_do_actual_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.s_async_input_stream_tester_do_actual_destroy","text":"s_async_input_stream_tester_do_actual_destroy(impl)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline void s_async_input_stream_tester_do_actual_destroy(struct aws_async_input_stream_tester *impl);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_async_input_stream_tester_do_actual_read-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_async_input_stream_tester_do_actual_read","text":"s_async_input_stream_tester_do_actual_read(impl, dest, read_future)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline void s_async_input_stream_tester_do_actual_read( struct aws_async_input_stream_tester *impl, struct aws_byte_buf *dest, struct aws_future_bool *read_future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_async_input_stream_tester_read-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_async_input_stream_tester_read","text":"s_async_input_stream_tester_read(stream, dest)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline struct aws_future_bool *s_async_input_stream_tester_read( struct aws_async_input_stream *stream, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_async_input_stream_tester_thread-Tuple{Any}","page":"Home","title":"LibAwsIO.s_async_input_stream_tester_thread","text":"s_async_input_stream_tester_thread(arg)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline void s_async_input_stream_tester_thread(void *arg);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_async_input_stream_tester_thread_pred-Tuple{Any}","page":"Home","title":"LibAwsIO.s_async_input_stream_tester_thread_pred","text":"s_async_input_stream_tester_thread_pred(arg)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline bool s_async_input_stream_tester_thread_pred(void *arg);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_byte_buf_init_autogenned-NTuple{4, Any}","page":"Home","title":"LibAwsIO.s_byte_buf_init_autogenned","text":"s_byte_buf_init_autogenned(buf, alloc, length, style)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline void s_byte_buf_init_autogenned( struct aws_byte_buf *buf, struct aws_allocator *alloc, size_t length, enum aws_autogen_style style);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_input_stream_tester_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.s_input_stream_tester_destroy","text":"s_input_stream_tester_destroy(user_data)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline void s_input_stream_tester_destroy(void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_input_stream_tester_get_length-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_input_stream_tester_get_length","text":"s_input_stream_tester_get_length(stream, out_length)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int s_input_stream_tester_get_length(struct aws_input_stream *stream, int64_t *out_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_input_stream_tester_get_status-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_input_stream_tester_get_status","text":"s_input_stream_tester_get_status(stream, status)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int s_input_stream_tester_get_status(struct aws_input_stream *stream, struct aws_stream_status *status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_input_stream_tester_read-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_input_stream_tester_read","text":"s_input_stream_tester_read(stream, original_dest)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int s_input_stream_tester_read(struct aws_input_stream *stream, struct aws_byte_buf *original_dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_input_stream_tester_seek-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_input_stream_tester_seek","text":"s_input_stream_tester_seek(stream, offset, basis)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int s_input_stream_tester_seek( struct aws_input_stream *stream, int64_t offset, enum aws_stream_seek_basis basis);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_new_testing_channel_handler-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_new_testing_channel_handler","text":"s_new_testing_channel_handler(allocator, initial_window)\n\nDocumentation not found.\n\nPrototype\n\nstatic struct aws_channel_handler *s_new_testing_channel_handler( struct aws_allocator *allocator, size_t initial_window);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_destroy","text":"s_testing_channel_handler_destroy(handler)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_channel_handler_destroy(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_gather_statistics-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_gather_statistics","text":"s_testing_channel_handler_gather_statistics(handler, stats)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_channel_handler_gather_statistics( struct aws_channel_handler *handler, struct aws_array_list *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_increment_read_window-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_increment_read_window","text":"s_testing_channel_handler_increment_read_window(handler, slot, size)\n\nDocumentation not found.\n\nPrototype\n\nstatic int s_testing_channel_handler_increment_read_window( struct aws_channel_handler *handler, struct aws_channel_slot *slot, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_initial_window_size-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_initial_window_size","text":"s_testing_channel_handler_initial_window_size(handler)\n\nDocumentation not found.\n\nPrototype\n\nstatic size_t s_testing_channel_handler_initial_window_size(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_message_overhead-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_message_overhead","text":"s_testing_channel_handler_message_overhead(handler)\n\nDocumentation not found.\n\nPrototype\n\nstatic size_t s_testing_channel_handler_message_overhead(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_process_read_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_process_read_message","text":"s_testing_channel_handler_process_read_message(handler, slot, message)\n\nDocumentation not found.\n\nPrototype\n\nstatic int s_testing_channel_handler_process_read_message( struct aws_channel_handler *handler, struct aws_channel_slot *slot, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_process_write_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_process_write_message","text":"s_testing_channel_handler_process_write_message(handler, slot, message)\n\nDocumentation not found.\n\nPrototype\n\nstatic int s_testing_channel_handler_process_write_message( struct aws_channel_handler *handler, struct aws_channel_slot *slot, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_reset_statistics-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_reset_statistics","text":"s_testing_channel_handler_reset_statistics(handler)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_channel_handler_reset_statistics(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_handler_shutdown-NTuple{5, Any}","page":"Home","title":"LibAwsIO.s_testing_channel_handler_shutdown","text":"s_testing_channel_handler_shutdown(handler, slot, dir, error_code, free_scarce_resources_immediately)\n\nDocumentation not found.\n\nPrototype\n\nstatic int s_testing_channel_handler_shutdown( struct aws_channel_handler *handler, struct aws_channel_slot *slot, enum aws_channel_direction dir, int error_code, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_on_setup_completed-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_testing_channel_on_setup_completed","text":"s_testing_channel_on_setup_completed(channel, error_code, user_data)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_channel_on_setup_completed(struct aws_channel *channel, int error_code, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_channel_on_shutdown_completed-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_testing_channel_on_shutdown_completed","text":"s_testing_channel_on_shutdown_completed(channel, error_code, user_data)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_channel_on_shutdown_completed(struct aws_channel *channel, int error_code, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_cancel_task-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_testing_loop_cancel_task","text":"s_testing_loop_cancel_task(event_loop, task)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_loop_cancel_task(struct aws_event_loop *event_loop, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_destroy-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_loop_destroy","text":"s_testing_loop_destroy(event_loop)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_loop_destroy(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_is_on_callers_thread-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_loop_is_on_callers_thread","text":"s_testing_loop_is_on_callers_thread(event_loop)\n\nDocumentation not found.\n\nPrototype\n\nstatic bool s_testing_loop_is_on_callers_thread(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_new-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_testing_loop_new","text":"s_testing_loop_new(allocator, clock)\n\nDocumentation not found.\n\nPrototype\n\nstatic struct aws_event_loop *s_testing_loop_new(struct aws_allocator *allocator, aws_io_clock_fn clock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_run-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_loop_run","text":"s_testing_loop_run(event_loop)\n\nDocumentation not found.\n\nPrototype\n\nstatic int s_testing_loop_run(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_schedule_task_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.s_testing_loop_schedule_task_future","text":"s_testing_loop_schedule_task_future(event_loop, task, run_at_nanos)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_loop_schedule_task_future( struct aws_event_loop *event_loop, struct aws_task *task, uint64_t run_at_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_schedule_task_now-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.s_testing_loop_schedule_task_now","text":"s_testing_loop_schedule_task_now(event_loop, task)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_testing_loop_schedule_task_now(struct aws_event_loop *event_loop, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_stop-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_loop_stop","text":"s_testing_loop_stop(event_loop)\n\nDocumentation not found.\n\nPrototype\n\nstatic int s_testing_loop_stop(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.s_testing_loop_wait_for_stop_completion-Tuple{Any}","page":"Home","title":"LibAwsIO.s_testing_loop_wait_for_stop_completion","text":"s_testing_loop_wait_for_stop_completion(event_loop)\n\nDocumentation not found.\n\nPrototype\n\nstatic int s_testing_loop_wait_for_stop_completion(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_check_messages_ex-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_check_messages_ex","text":"testing_channel_check_messages_ex(msgs, allocator, expected)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_check_messages_ex( struct aws_linked_list *msgs, struct aws_allocator *allocator, struct aws_byte_cursor expected);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_check_midchannel_read_messages-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_check_midchannel_read_messages","text":"testing_channel_check_midchannel_read_messages(channel, allocator, expected)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_check_midchannel_read_messages( struct testing_channel *channel, struct aws_allocator *allocator, struct aws_byte_cursor expected);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_check_midchannel_read_messages_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_check_midchannel_read_messages_str","text":"testing_channel_check_midchannel_read_messages_str(channel, allocator, expected)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_check_midchannel_read_messages_str( struct testing_channel *channel, struct aws_allocator *allocator, const char *expected);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_check_written_message-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_check_written_message","text":"testing_channel_check_written_message(channel, expected)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_check_written_message( struct testing_channel *channel, struct aws_byte_cursor expected);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_check_written_message_str-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_check_written_message_str","text":"testing_channel_check_written_message_str(channel, expected)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_check_written_message_str(struct testing_channel *channel, const char *expected);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_check_written_messages-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_check_written_messages","text":"testing_channel_check_written_messages(channel, allocator, expected)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_check_written_messages( struct testing_channel *channel, struct aws_allocator *allocator, struct aws_byte_cursor expected);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_check_written_messages_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_check_written_messages_str","text":"testing_channel_check_written_messages_str(channel, allocator, expected)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_check_written_messages_str( struct testing_channel *channel, struct aws_allocator *allocator, const char *expected);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_clean_up-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_clean_up","text":"testing_channel_clean_up(testing)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_clean_up(struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_complete_written_messages_immediately-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_complete_written_messages_immediately","text":"testing_channel_complete_written_messages_immediately(testing, complete_immediately, complete_error_code)\n\nSet whether written messages have their on_complete callbacks invoked immediately. The on_complete callback will be cleared after it is invoked.\n\nPrototype\n\nstatic inline void testing_channel_complete_written_messages_immediately( struct testing_channel *testing, bool complete_immediately, int complete_error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_drain_messages-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_drain_messages","text":"testing_channel_drain_messages(msgs, buffer)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_drain_messages(struct aws_linked_list *msgs, struct aws_byte_buf *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_drain_queued_tasks-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_drain_queued_tasks","text":"testing_channel_drain_queued_tasks(testing)\n\nRepeatedly executes scheduled tasks until only those in the future remain. This covers the common case where there's a chain reaction of now-tasks scheduling further now-tasks.\n\nPrototype\n\nstatic inline void testing_channel_drain_queued_tasks(struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_drain_written_messages-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_drain_written_messages","text":"testing_channel_drain_written_messages(channel, output)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_drain_written_messages(struct testing_channel *channel, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_get_read_message_queue-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_get_read_message_queue","text":"testing_channel_get_read_message_queue(testing)\n\nwhen you want to test the read output of your handler, call this, get the queue and iterate the messages. A downstream handler must have been installed\n\nPrototype\n\nstatic inline struct aws_linked_list *testing_channel_get_read_message_queue(struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_get_shutdown_error_code-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_get_shutdown_error_code","text":"testing_channel_get_shutdown_error_code(testing)\n\nReturn channel's shutdown error_code\n\nPrototype\n\nstatic inline int testing_channel_get_shutdown_error_code(const struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_get_written_message_queue-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_get_written_message_queue","text":"testing_channel_get_written_message_queue(testing)\n\nwhen you want to test the write output of your handler, call this, get the queue and iterate the messages.\n\nPrototype\n\nstatic inline struct aws_linked_list *testing_channel_get_written_message_queue(struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_increment_read_window","text":"testing_channel_increment_read_window(testing, size)\n\nWhen you want the downstream handler to issue a window update\n\nPrototype\n\nstatic inline int testing_channel_increment_read_window(struct testing_channel *testing, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_init","text":"testing_channel_init(testing, allocator, options)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_init( struct testing_channel *testing, struct aws_allocator *allocator, struct aws_testing_channel_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_install_downstream_handler-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_install_downstream_handler","text":"testing_channel_install_downstream_handler(testing, initial_window)\n\nWhen you want to test your handler with a downstream handler installed to the right.\n\nPrototype\n\nstatic inline int testing_channel_install_downstream_handler(struct testing_channel *testing, size_t initial_window);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_is_shutdown_completed-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_is_shutdown_completed","text":"testing_channel_is_shutdown_completed(testing)\n\nReturn whether channel is completely shut down\n\nPrototype\n\nstatic inline bool testing_channel_is_shutdown_completed(const struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_last_window_update-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_last_window_update","text":"testing_channel_last_window_update(testing)\n\nWhen you want to see what the latest window update issues from your channel handler was, call this.\n\nPrototype\n\nstatic inline size_t testing_channel_last_window_update(struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_push_read_data-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_push_read_data","text":"testing_channel_push_read_data(channel, data)\n\nCreate an aws_io_message, containing the following data, and pushes it up the channel in the read direction\n\nPrototype\n\nstatic inline int testing_channel_push_read_data(struct testing_channel *channel, struct aws_byte_cursor data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_push_read_message-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_push_read_message","text":"testing_channel_push_read_message(testing, message)\n\nwhen you want to test the read path of your handler, call this with the message you want it to read.\n\nPrototype\n\nstatic inline int testing_channel_push_read_message(struct testing_channel *testing, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_push_read_str-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_push_read_str","text":"testing_channel_push_read_str(channel, str)\n\nCreate an aws_io_message, containing the following data, and pushes it up the channel in the read direction\n\nPrototype\n\nstatic inline int testing_channel_push_read_str(struct testing_channel *channel, const char *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_push_read_str_ignore_errors-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_push_read_str_ignore_errors","text":"testing_channel_push_read_str_ignore_errors(channel, str)\n\nCreate an aws_io_message, containing the following data. Tries to push it up the channel in the read direction, but don't assert if the message can't be sent. Useful for testing data that arrives during handler shutdown\n\nPrototype\n\nstatic inline int testing_channel_push_read_str_ignore_errors(struct testing_channel *channel, const char *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_push_write_data-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_push_write_data","text":"testing_channel_push_write_data(channel, data)\n\nCreate an aws_io_message, containing the following data, and pushes it up the channel in the write direction\n\nPrototype\n\nstatic inline int testing_channel_push_write_data(struct testing_channel *channel, struct aws_byte_cursor data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_push_write_message-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_push_write_message","text":"testing_channel_push_write_message(testing, message)\n\nwhen you want to test the write path of your handler, call this with the message you want it to write. A downstream handler must have been installed\n\nPrototype\n\nstatic inline int testing_channel_push_write_message(struct testing_channel *testing, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_push_write_str-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_push_write_str","text":"testing_channel_push_write_str(channel, str)\n\nCreate an aws_io_message, containing the following data, and pushes it up the channel in the write direction\n\nPrototype\n\nstatic inline int testing_channel_push_write_str(struct testing_channel *channel, const char *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_run_currently_queued_tasks-Tuple{Any}","page":"Home","title":"LibAwsIO.testing_channel_run_currently_queued_tasks","text":"testing_channel_run_currently_queued_tasks(testing)\n\nExecutes all currently scheduled tasks whose time has come. Use testing_channel_drain_queued_tasks() to repeatedly run tasks until only future-tasks remain.\n\nPrototype\n\nstatic inline void testing_channel_run_currently_queued_tasks(struct testing_channel *testing);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_send_data-NTuple{4, Any}","page":"Home","title":"LibAwsIO.testing_channel_send_data","text":"testing_channel_send_data(channel, data, dir, ignore_send_message_errors)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int testing_channel_send_data( struct testing_channel *channel, struct aws_byte_cursor data, enum aws_channel_direction dir, bool ignore_send_message_errors);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_set_downstream_handler_shutdown_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_set_downstream_handler_shutdown_callback","text":"testing_channel_set_downstream_handler_shutdown_callback(testing, on_shutdown, user_data)\n\nSet a callback which is invoked during the handler's shutdown, once in the read direction and again in the write direction. Use this to inject actions that might occur in the middle of channel shutdown.\n\nPrototype\n\nstatic inline void testing_channel_set_downstream_handler_shutdown_callback( struct testing_channel *testing, testing_channel_handler_on_shutdown_fn *on_shutdown, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsIO.testing_channel_set_is_on_users_thread-Tuple{Any, Any}","page":"Home","title":"LibAwsIO.testing_channel_set_is_on_users_thread","text":"testing_channel_set_is_on_users_thread(testing, on_users_thread)\n\nWhen you want to force the \"not on channel thread path\" for your handler, set 'on_users_thread' to false. when you want to undo that, set it back to true. If you set it to false, you'll need to call 'testing_channel_execute_queued_tasks()' to invoke the tasks that ended up being scheduled.\n\nPrototype\n\nstatic inline void testing_channel_set_is_on_users_thread(struct testing_channel *testing, bool on_users_thread);\n\n\n\n\n\n","category":"method"}]
}
